<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XsController: Callback functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xsenslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XsController
   &#160;<span id="projectnumber">2021.4.0</span>
   </div>
   <div id="projectbrief">Xsens Device API Public Communication Objects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___callbacks.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Callback functions.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga270ee8957dac53bdf04aee0ba40b3c03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03">XsCallback::onAllBufferedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga270ee8957dac53bdf04aee0ba40b3c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03">More...</a><br /></td></tr>
<tr class="separator:ga270ee8957dac53bdf04aee0ba40b3c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4e17817075f23aa461ecf92bb997ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba">XsCallback::onAllDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaeb4e17817075f23aa461ecf92bb997ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba">More...</a><br /></td></tr>
<tr class="separator:gaeb4e17817075f23aa461ecf92bb997ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7bf7c16f2f8bf70da7150f8a68ac95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95">XsCallback::onAllLiveDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga4e7bf7c16f2f8bf70da7150f8a68ac95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95">More...</a><br /></td></tr>
<tr class="separator:ga4e7bf7c16f2f8bf70da7150f8a68ac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c054ebc03662aa3bc88d36916d8d3f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6">XsCallback::onAllRecordedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga6c054ebc03662aa3bc88d36916d8d3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6">More...</a><br /></td></tr>
<tr class="separator:ga6c054ebc03662aa3bc88d36916d8d3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397146fde21cd36a801206e9b73d8399"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399">XsCallback::onBufferedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga397146fde21cd36a801206e9b73d8399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399">More...</a><br /></td></tr>
<tr class="separator:ga397146fde21cd36a801206e9b73d8399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad6280b5dc0c8e458b22e26a50bad40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40">XsCallback::onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:gacad6280b5dc0c8e458b22e26a50bad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40">More...</a><br /></td></tr>
<tr class="separator:gacad6280b5dc0c8e458b22e26a50bad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a65730e9aa35fe9c52c92807741f088"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088">XsCallback::onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga9a65730e9aa35fe9c52c92807741f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088">More...</a><br /></td></tr>
<tr class="separator:ga9a65730e9aa35fe9c52c92807741f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d308afd509c0325b4cdb622fd9e645"><td class="memItemLeft" align="right" valign="top"><a id="ga89d308afd509c0325b4cdb622fd9e645"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga89d308afd509c0325b4cdb622fd9e645">XsCallback::onDataUnavailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga89d308afd509c0325b4cdb622fd9e645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable. <br /></td></tr>
<tr class="separator:ga89d308afd509c0325b4cdb622fd9e645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="memItemLeft" align="right" valign="top"><a id="ga24d179eecbcde2ca2f3206cb6f7c05f0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0">XsCallback::onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode) <br /></td></tr>
<tr class="separator:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4a31e495dde9ee053c070fbf06cbe89f">XsCallback::onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="group___callbacks.html#ga4a31e495dde9ee053c070fbf06cbe89f">More...</a><br /></td></tr>
<tr class="separator:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5">XsCallback::onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5">More...</a><br /></td></tr>
<tr class="separator:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94a5a76c3a443255fc53f7a2bf9e076"><td class="memItemLeft" align="right" valign="top"><a id="gaf94a5a76c3a443255fc53f7a2bf9e076"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076">XsCallback::onLiveDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf94a5a76c3a443255fc53f7a2bf9e076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. <br /></td></tr>
<tr class="separator:gaf94a5a76c3a443255fc53f7a2bf9e076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed964edc07fece9546cdd67f64e29f24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaed964edc07fece9546cdd67f64e29f24">XsCallback::onMessageDetected</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:gaed964edc07fece9546cdd67f64e29f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="group___callbacks.html#gaed964edc07fece9546cdd67f64e29f24">More...</a><br /></td></tr>
<tr class="separator:gaed964edc07fece9546cdd67f64e29f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7cc6f779fca5b3ced0480a731991b18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf7cc6f779fca5b3ced0480a731991b18">XsCallback::onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gaf7cc6f779fca5b3ced0480a731991b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="group___callbacks.html#gaf7cc6f779fca5b3ced0480a731991b18">More...</a><br /></td></tr>
<tr class="separator:gaf7cc6f779fca5b3ced0480a731991b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae0b5c78ecbf3e01a754d4591cb88294f">XsCallback::onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="group___callbacks.html#gae0b5c78ecbf3e01a754d4591cb88294f">More...</a><br /></td></tr>
<tr class="separator:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="memItemLeft" align="right" valign="top"><a id="ga32f20ce601f007ba4e571e40a4f8f71e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e">XsCallback::onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed. <br /></td></tr>
<tr class="separator:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656b04fa94f7b374dcbda27dba20b835"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga656b04fa94f7b374dcbda27dba20b835">XsCallback::onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga656b04fa94f7b374dcbda27dba20b835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="group___callbacks.html#ga656b04fa94f7b374dcbda27dba20b835">More...</a><br /></td></tr>
<tr class="separator:ga656b04fa94f7b374dcbda27dba20b835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="memItemLeft" align="right" valign="top"><a id="ga70ff4796b9bb5e3d79eac2c7cd870e59"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59">XsCallback::onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed. <br /></td></tr>
<tr class="separator:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882b4ffadbc4ac28c78a9763de623c14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14">XsCallback::onRecordedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga882b4ffadbc4ac28c78a9763de623c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14">More...</a><br /></td></tr>
<tr class="separator:ga882b4ffadbc4ac28c78a9763de623c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad70ca84a25f9e01507dde5972262b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gadad70ca84a25f9e01507dde5972262b8">XsCallback::onRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:gadad70ca84a25f9e01507dde5972262b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occurred.  <a href="group___callbacks.html#gadad70ca84a25f9e01507dde5972262b8">More...</a><br /></td></tr>
<tr class="separator:gadad70ca84a25f9e01507dde5972262b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa584015b7c370591fc66f354968a9ca8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa584015b7c370591fc66f354968a9ca8">XsCallback::onTransmissionRequest</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa584015b7c370591fc66f354968a9ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="group___callbacks.html#gaa584015b7c370591fc66f354968a9ca8">More...</a><br /></td></tr>
<tr class="separator:gaa584015b7c370591fc66f354968a9ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="memItemLeft" align="right" valign="top"><a id="gac8d7f94d6cb77f5fe56effaa36752e4a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a">XsCallback::onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in. <br /></td></tr>
<tr class="separator:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d34298b034dda9f344f3eb9fc132290"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290">XsCallback::onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:ga5d34298b034dda9f344f3eb9fc132290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290">More...</a><br /></td></tr>
<tr class="separator:ga5d34298b034dda9f344f3eb9fc132290"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga530314b978cfc8e67a428ef5977e387c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">XsCallbackPlainC::m_onAllBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga530314b978cfc8e67a428ef5977e387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">More...</a><br /></td></tr>
<tr class="separator:ga530314b978cfc8e67a428ef5977e387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd8acc66bddf7d1ee079836e0ce36"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">XsCallbackPlainC::m_onAllDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaf2ecd8acc66bddf7d1ee079836e0ce36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">More...</a><br /></td></tr>
<tr class="separator:gaf2ecd8acc66bddf7d1ee079836e0ce36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2a40680bf18c67190bf81439c4e19d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">XsCallbackPlainC::m_onAllLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga3c2a40680bf18c67190bf81439c4e19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">More...</a><br /></td></tr>
<tr class="separator:ga3c2a40680bf18c67190bf81439c4e19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdcbea991503b517e4f84f39ee116a4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">XsCallbackPlainC::m_onAllRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaccdcbea991503b517e4f84f39ee116a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">More...</a><br /></td></tr>
<tr class="separator:gaccdcbea991503b517e4f84f39ee116a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae186ea85d702212393fc4da478088a05"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">XsCallbackPlainC::m_onBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gae186ea85d702212393fc4da478088a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">More...</a><br /></td></tr>
<tr class="separator:gae186ea85d702212393fc4da478088a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2d3d70d8db257a5e97887576eed19b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">XsCallbackPlainC::m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga7a2d3d70d8db257a5e97887576eed19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">More...</a><br /></td></tr>
<tr class="separator:ga7a2d3d70d8db257a5e97887576eed19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35dbb77b7b08bc8b8e23e6b64c5e87e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">XsCallbackPlainC::m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf35dbb77b7b08bc8b8e23e6b64c5e87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">More...</a><br /></td></tr>
<tr class="separator:gaf35dbb77b7b08bc8b8e23e6b64c5e87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422f718cc9c4af42b868b998d106eb7a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">XsCallbackPlainC::m_onDataUnavailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga422f718cc9c4af42b868b998d106eb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable.  <a href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">More...</a><br /></td></tr>
<tr class="separator:ga422f718cc9c4af42b868b998d106eb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8246e1d43087d9a1d559b4015cc5a828"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">XsCallbackPlainC::m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga8246e1d43087d9a1d559b4015cc5a828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">More...</a><br /></td></tr>
<tr class="separator:ga8246e1d43087d9a1d559b4015cc5a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6a9805f05f1d3128064be4bc08413b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">XsCallbackPlainC::m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga0e6a9805f05f1d3128064be4bc08413b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">More...</a><br /></td></tr>
<tr class="separator:ga0e6a9805f05f1d3128064be4bc08413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d8b003d9966a2e3ad3a46d0732a97c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">XsCallbackPlainC::m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga91d8b003d9966a2e3ad3a46d0732a97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">More...</a><br /></td></tr>
<tr class="separator:ga91d8b003d9966a2e3ad3a46d0732a97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e69823b97ba679d3937ddc140bbc15c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">XsCallbackPlainC::m_onLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga4e69823b97ba679d3937ddc140bbc15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">More...</a><br /></td></tr>
<tr class="separator:ga4e69823b97ba679d3937ddc140bbc15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb5e439c458d9704f3ddc05675f8193"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">XsCallbackPlainC::m_onMessageDetected</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:ga9eb5e439c458d9704f3ddc05675f8193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">More...</a><br /></td></tr>
<tr class="separator:ga9eb5e439c458d9704f3ddc05675f8193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f44ee52c284329ef2deb811ec162833"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">XsCallbackPlainC::m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga1f44ee52c284329ef2deb811ec162833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">More...</a><br /></td></tr>
<tr class="separator:ga1f44ee52c284329ef2deb811ec162833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3ec2b8c9d9a437d6979ca3285abc90"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">XsCallbackPlainC::m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gadb3ec2b8c9d9a437d6979ca3285abc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">More...</a><br /></td></tr>
<tr class="separator:gadb3ec2b8c9d9a437d6979ca3285abc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bc7b8493223ddd47c439d0a5b50f8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">XsCallbackPlainC::m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga406bc7b8493223ddd47c439d0a5b50f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">More...</a><br /></td></tr>
<tr class="separator:ga406bc7b8493223ddd47c439d0a5b50f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade81af9d98086c3a760ffa3686045c63"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">XsCallbackPlainC::m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gade81af9d98086c3a760ffa3686045c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">More...</a><br /></td></tr>
<tr class="separator:gade81af9d98086c3a760ffa3686045c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131fcde042d419e07dd2144b5d2d36e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">XsCallbackPlainC::m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga0131fcde042d419e07dd2144b5d2d36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">More...</a><br /></td></tr>
<tr class="separator:ga0131fcde042d419e07dd2144b5d2d36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8c139d2c3c55805d73511457956005"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">XsCallbackPlainC::m_onRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8b8c139d2c3c55805d73511457956005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">More...</a><br /></td></tr>
<tr class="separator:ga8b8c139d2c3c55805d73511457956005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140e7bfb9bfadef2a1f22671f936ff14"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">XsCallbackPlainC::m_onRestoreCommunication</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga140e7bfb9bfadef2a1f22671f936ff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occurred.  <a href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">More...</a><br /></td></tr>
<tr class="separator:ga140e7bfb9bfadef2a1f22671f936ff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d90a461c21f3e14756360027e6658b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">XsCallbackPlainC::m_onTransmissionRequest</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa5d90a461c21f3e14756360027e6658b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">More...</a><br /></td></tr>
<tr class="separator:gaa5d90a461c21f3e14756360027e6658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14d44ea1773133b68b01ae53af8ab8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">XsCallbackPlainC::m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9f14d44ea1773133b68b01ae53af8ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">More...</a><br /></td></tr>
<tr class="separator:ga9f14d44ea1773133b68b01ae53af8ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc866d3a718e0351a9d23a2d1ec2586a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">XsCallbackPlainC::m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gacc866d3a718e0351a9d23a2d1ec2586a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">More...</a><br /></td></tr>
<tr class="separator:gacc866d3a718e0351a9d23a2d1ec2586a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga270ee8957dac53bdf04aee0ba40b3c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga270ee8957dac53bdf04aee0ba40b3c03">&#9670;&nbsp;</a></span>onAllBufferedDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllBufferedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. This stream will only interpolate data that is knon to be permanently unavailable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#af2827956387a56712723e9200882179c">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="gaeb4e17817075f23aa461ecf92bb997ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4e17817075f23aa461ecf92bb997ba">&#9670;&nbsp;</a></span>onAllDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a5f103ff688afdeef381eedd6100331d2">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga4e7bf7c16f2f8bf70da7150f8a68ac95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e7bf7c16f2f8bf70da7150f8a68ac95">&#9670;&nbsp;</a></span>onAllLiveDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllLiveDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Live stream, so there may be gaps in the data, but it will always contain the latest data. This stream will interpolate missing data to provide the fastest data output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a5e64d70ce299958605b6149049e045ef">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga6c054ebc03662aa3bc88d36916d8d3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c054ebc03662aa3bc88d36916d8d3f6">&#9670;&nbsp;</a></span>onAllRecordedDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllRecordedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a4c0aa7e3be74595cef490b98d1520d1e">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga397146fde21cd36a801206e9b73d8399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397146fde21cd36a801206e9b73d8399">&#9670;&nbsp;</a></span>onBufferedDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onBufferedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has a data packet that could be written to a log file. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290" title="Called when XDA has a message that could be written to a log file.">onWriteMessageToLogFile</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#ad4c8eb08edd64025b3e9405415b38834">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="gacad6280b5dc0c8e458b22e26a50bad40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad6280b5dc0c8e458b22e26a50bad40">&#9670;&nbsp;</a></span>onConnectivityChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onConnectivityChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td>
          <td class="paramname"><em>newState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has detected a change in the connectivity state of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">newState</td><td>The new connectivity state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a312575546ab44f788dd3961477ba0e7f">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga9a65730e9aa35fe9c52c92807741f088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a65730e9aa35fe9c52c92807741f088">&#9670;&nbsp;</a></span>onDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device....">m_onAllDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#acc815adc25af17f24207573afa9c94da">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga4a31e495dde9ee053c070fbf06cbe89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a31e495dde9ee053c070fbf06cbe89f">&#9670;&nbsp;</a></span>onError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an error has occurred while handling incoming data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">error</td><td>The error code that specifies exactly what problem occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a3a65ae9866cb7a9e8ab11dcfeca1572f">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga224586f8f7e0e9f0b57091b7d9a24bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga224586f8f7e0e9f0b57091b7d9a24bc5">&#9670;&nbsp;</a></span>onInfoResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onInfoResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a>&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an information request has resulted in a response. </p>
<p>When the information request has completed, the data can be retrieved through the usual functions. Ie. when a requestBatteryLevel() resulted in an onInfoResponse(.., XIR_BatteryLevel), the <a class="el" href="struct_xs_device.html#a9d02e390ddc757bf9b16697cc5674ee0" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">XsDevice::batteryLevel</a> function will return the received battery level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">request</td><td>The type of request that was completed </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="gaed964edc07fece9546cdd67f64e29f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed964edc07fece9546cdd67f64e29f24">&#9670;&nbsp;</a></span>onMessageDetected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageDetected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *&#160;</td>
          <td class="paramname"><em>rawMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a message is detected in raw data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">type</td><td>The protocol type that detected a message </td></tr>
    <tr><td class="paramname">rawMessage</td><td>The raw message that has been detected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This message can be invalid, since it wasn't checked for sanity </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#af81b39fa94f8086d9682df2e53ea5e1e">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="gaf7cc6f779fca5b3ced0480a731991b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7cc6f779fca5b3ced0480a731991b18">&#9670;&nbsp;</a></span>onMessageReceivedFromDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageReceivedFromDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a valid message (after parsing) is received from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a760e93d7f7142fd22c7e134c4cea5f72">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="gae0b5c78ecbf3e01a754d4591cb88294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0b5c78ecbf3e01a754d4591cb88294f">&#9670;&nbsp;</a></span>onMessageSentToDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageSentToDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a message is sent to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that will receive the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a73ec10bd8e7cf2df6b4136ad0ac9701e">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga656b04fa94f7b374dcbda27dba20b835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga656b04fa94f7b374dcbda27dba20b835">&#9670;&nbsp;</a></span>onNonDataMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onNonDataMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a non data, non reply message has been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#afdeff1e1697266d82f232642aef0cae9">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga882b4ffadbc4ac28c78a9763de623c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga882b4ffadbc4ac28c78a9763de623c14">&#9670;&nbsp;</a></span>onRecordedDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onRecordedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device....">m_onAllDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a5b6beccc0e4760b652b7be01e859e465">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="gadad70ca84a25f9e01507dde5972262b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadad70ca84a25f9e01507dde5972262b8">&#9670;&nbsp;</a></span>onRestoreCommunication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onRestoreCommunication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>portName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when restore communication is completed, stopped or an error occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portName</td><td>A name of port to which device is attached. </td></tr>
    <tr><td class="paramname">result</td><td>The result code. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#af91bb23b63beb62d085182044abb30a7">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="gaa584015b7c370591fc66f354968a9ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa584015b7c370591fc66f354968a9ca8">&#9670;&nbsp;</a></span>onTransmissionRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onTransmissionRequest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA needs to send raw data to a device connected using a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user provided identifier associated with the custom channel. </td></tr>
    <tr><td class="paramname">data</td><td>The array of bytes that must be forwarded to the device </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">CallbackManagerXda</a>.</p>

</div>
</div>
<a id="ga5d34298b034dda9f344f3eb9fc132290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d34298b034dda9f344f3eb9fc132290">&#9670;&nbsp;</a></span>onWriteMessageToLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int XsCallback::onWriteMessageToLogFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has a message that could be written to a log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>m_onWriteDataToLogFile </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#ad510877b529df7a85fbc5d601c2fad76">CallbackManagerXda</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga530314b978cfc8e67a428ef5977e387c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga530314b978cfc8e67a428ef5977e387c">&#9670;&nbsp;</a></span>m_onAllBufferedDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllBufferedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. This stream will only interpolate data that is knon to be permanently unavailable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

</div>
</div>
<a id="gaf2ecd8acc66bddf7d1ee079836e0ce36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ecd8acc66bddf7d1ee079836e0ce36">&#9670;&nbsp;</a></span>m_onAllDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

</div>
</div>
<a id="ga3c2a40680bf18c67190bf81439c4e19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c2a40680bf18c67190bf81439c4e19d">&#9670;&nbsp;</a></span>m_onAllLiveDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllLiveDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Live stream, so there may be gaps in the data, but it will always contain the latest data. This stream will interpolate missing data to provide the fastest data output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

</div>
</div>
<a id="gaccdcbea991503b517e4f84f39ee116a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccdcbea991503b517e4f84f39ee116a4">&#9670;&nbsp;</a></span>m_onAllRecordedDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllRecordedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

</div>
</div>
<a id="gae186ea85d702212393fc4da478088a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae186ea85d702212393fc4da478088a05">&#9670;&nbsp;</a></span>m_onBufferedDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onBufferedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has a data packet that could be written to a log file. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>onWriteMessageToLogFile </dd>
<dd>
<a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

</div>
</div>
<a id="ga7a2d3d70d8db257a5e97887576eed19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a2d3d70d8db257a5e97887576eed19b">&#9670;&nbsp;</a></span>m_onConnectivityChanged</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onConnectivityChanged) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has detected a change in the connectivity state of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">newState</td><td>The new connectivity state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf35dbb77b7b08bc8b8e23e6b64c5e87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">&#9670;&nbsp;</a></span>m_onDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device....">m_onAllDataAvailable</a> </dd></dl>

</div>
</div>
<a id="ga422f718cc9c4af42b868b998d106eb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga422f718cc9c4af42b868b998d106eb7a">&#9670;&nbsp;</a></span>m_onDataUnavailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDataUnavailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA detects that data is forever unavailable. </p>
<p>This differs from onMissedPackets, since missed packets may be retransmitted, while unavailable data can no longer be retransmitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packetId</td><td>The sample counter / packet identifier of the unavailable sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8246e1d43087d9a1d559b4015cc5a828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8246e1d43087d9a1d559b4015cc5a828">&#9670;&nbsp;</a></span>m_onDeviceStateChanged</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDeviceStateChanged) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a device's state has changed (ie config mode, measurement mode, recording mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 in some cases. </td></tr>
    <tr><td class="paramname">newState</td><td>The new device state </td></tr>
    <tr><td class="paramname">oldState</td><td>The old device state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e6a9805f05f1d3128064be4bc08413b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e6a9805f05f1d3128064be4bc08413b">&#9670;&nbsp;</a></span>m_onError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onError) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an error has occurred while handling incoming data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">error</td><td>The error code that specifies exactly what problem occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91d8b003d9966a2e3ad3a46d0732a97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91d8b003d9966a2e3ad3a46d0732a97c">&#9670;&nbsp;</a></span>m_onInfoResponse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onInfoResponse) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an information request has resulted in a response. </p>
<p>When the information request has completed, the data can be retrieved through the usual functions. Ie. when a requestBatteryLevel() resulted in an onInfoResponse(.., XIR_BatteryLevel), the <a class="el" href="struct_xs_device.html#a9d02e390ddc757bf9b16697cc5674ee0" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">XsDevice::batteryLevel</a> function will return the received battery level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">request</td><td>The type of request that was completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e69823b97ba679d3937ddc140bbc15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e69823b97ba679d3937ddc140bbc15c">&#9670;&nbsp;</a></span>m_onLiveDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onLiveDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Live stream, so there may be gaps in the data, but it will always contain the latest data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

</div>
</div>
<a id="ga9eb5e439c458d9704f3ddc05675f8193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eb5e439c458d9704f3ddc05675f8193">&#9670;&nbsp;</a></span>m_onMessageDetected</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageDetected) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const  *rawMessage)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a message is detected in raw data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">type</td><td>The protocol type that detected a message </td></tr>
    <tr><td class="paramname">rawMessage</td><td>The raw message that has been detected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This message can be invalid, since it wasn't checked for sanity </dd></dl>

</div>
</div>
<a id="ga1f44ee52c284329ef2deb811ec162833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f44ee52c284329ef2deb811ec162833">&#9670;&nbsp;</a></span>m_onMessageReceivedFromDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageReceivedFromDevice) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const  *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a valid message (after parsing) is received from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb3ec2b8c9d9a437d6979ca3285abc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb3ec2b8c9d9a437d6979ca3285abc90">&#9670;&nbsp;</a></span>m_onMessageSentToDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageSentToDevice) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const  *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a message is sent to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that will receive the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga406bc7b8493223ddd47c439d0a5b50f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga406bc7b8493223ddd47c439d0a5b50f8">&#9670;&nbsp;</a></span>m_onMissedPackets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMissedPackets) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA detects that packets have been missed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">count</td><td>The number of samples that were missed </td></tr>
    <tr><td class="paramname">first</td><td>The sample counter / packet identifier of the first missed sample </td></tr>
    <tr><td class="paramname">last</td><td>The sample counter / packet identifier of the last missed sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade81af9d98086c3a760ffa3686045c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade81af9d98086c3a760ffa3686045c63">&#9670;&nbsp;</a></span>m_onNonDataMessage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onNonDataMessage) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const  *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a non data, non reply message has been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0131fcde042d419e07dd2144b5d2d36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0131fcde042d419e07dd2144b5d2d36e">&#9670;&nbsp;</a></span>m_onProgressUpdated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onProgressUpdated) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">current</td><td>The current progress. </td></tr>
    <tr><td class="paramname">total</td><td>The total work to be done. When <em>current</em> equals <em>total</em>, the task is completed. </td></tr>
    <tr><td class="paramname">identifier</td><td>An identifier for the task. This may for example be a filename for file read operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b8c139d2c3c55805d73511457956005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8c139d2c3c55805d73511457956005">&#9670;&nbsp;</a></span>m_onRecordedDataAvailable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onRecordedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device....">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device....">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file.">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device....">m_onAllDataAvailable</a> </dd></dl>

</div>
</div>
<a id="ga140e7bfb9bfadef2a1f22671f936ff14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140e7bfb9bfadef2a1f22671f936ff14">&#9670;&nbsp;</a></span>m_onRestoreCommunication</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onRestoreCommunication) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when restore communication is completed, stopped or an error occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portName</td><td>A name of port to which device is attached. </td></tr>
    <tr><td class="paramname">result</td><td>The result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5d90a461c21f3e14756360027e6658b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d90a461c21f3e14756360027e6658b">&#9670;&nbsp;</a></span>m_onTransmissionRequest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onTransmissionRequest) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA needs to send raw data to a device connected using a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user provided identifier associated with the custom channel. </td></tr>
    <tr><td class="paramname">data</td><td>The array of bytes that must be forwarded to the device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f14d44ea1773133b68b01ae53af8ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f14d44ea1773133b68b01ae53af8ab8">&#9670;&nbsp;</a></span>m_onWakeupReceived</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onWakeupReceived) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc866d3a718e0351a9d23a2d1ec2586a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc866d3a718e0351a9d23a2d1ec2586a">&#9670;&nbsp;</a></span>m_onWriteMessageToLogFile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* XsCallbackPlainC::m_onWriteMessageToLogFile) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has a message that could be written to a log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>m_onWriteDataToLogFile </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
