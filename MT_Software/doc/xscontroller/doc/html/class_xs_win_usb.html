<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XsController: XsWinUsb Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xsenslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XsController
   &#160;<span id="projectnumber">2021.4.0</span>
   </div>
   <div id="projectbrief">Xsens Device API Public Communication Objects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_xs_win_usb.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_xs_win_usb-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsWinUsb Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for dynamic loading of winusb.  
 <a href="class_xs_win_usb.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a13dafb21dcad4ededde9d8defdcaa94a"><td class="memItemLeft" align="right" valign="top">WinUSB_AbortPipe&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a13dafb21dcad4ededde9d8defdcaa94a">AbortPipe</a></td></tr>
<tr class="memdesc:a13dafb21dcad4ededde9d8defdcaa94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts all of the pending transfers for a pipe.  <a href="class_xs_win_usb.html#a13dafb21dcad4ededde9d8defdcaa94a">More...</a><br /></td></tr>
<tr class="separator:a13dafb21dcad4ededde9d8defdcaa94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0958714bebe476ccf1694eeb76ee3517"><td class="memItemLeft" align="right" valign="top">WinUSB_ControlTransfer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a0958714bebe476ccf1694eeb76ee3517">ControlTransfer</a></td></tr>
<tr class="memdesc:a0958714bebe476ccf1694eeb76ee3517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits control data over a default control endpoint. A ControlTransfer is never cached. These requests always go directly to the usb device.  <a href="class_xs_win_usb.html#a0958714bebe476ccf1694eeb76ee3517">More...</a><br /></td></tr>
<tr class="separator:a0958714bebe476ccf1694eeb76ee3517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907449242f581fc9e82a926e774482f9"><td class="memItemLeft" align="right" valign="top">WinUSB_FlushPipe&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a907449242f581fc9e82a926e774482f9">FlushPipe</a></td></tr>
<tr class="memdesc:a907449242f581fc9e82a926e774482f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards any data that is cached in a pipe.  <a href="class_xs_win_usb.html#a907449242f581fc9e82a926e774482f9">More...</a><br /></td></tr>
<tr class="separator:a907449242f581fc9e82a926e774482f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5116b15ec3c1ed6a126c4d64e5a88"><td class="memItemLeft" align="right" valign="top">WinUSB_Free&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#ae1e5116b15ec3c1ed6a126c4d64e5a88">Free</a></td></tr>
<tr class="memdesc:ae1e5116b15ec3c1ed6a126c4d64e5a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a WinUsb interface handle.  <a href="class_xs_win_usb.html#ae1e5116b15ec3c1ed6a126c4d64e5a88">More...</a><br /></td></tr>
<tr class="separator:ae1e5116b15ec3c1ed6a126c4d64e5a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2de64e0643d7d0aaef813ea41ae41f9"><td class="memItemLeft" align="right" valign="top">WinUSB_GetAssociatedInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#ad2de64e0643d7d0aaef813ea41ae41f9">GetAssociatedInterface</a></td></tr>
<tr class="memdesc:ad2de64e0643d7d0aaef813ea41ae41f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a handle for an associated interface.  <a href="class_xs_win_usb.html#ad2de64e0643d7d0aaef813ea41ae41f9">More...</a><br /></td></tr>
<tr class="separator:ad2de64e0643d7d0aaef813ea41ae41f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58e940e4931f713422badcd46845e8a"><td class="memItemLeft" align="right" valign="top">WinUSB_GetCurrentAlternateSetting&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#af58e940e4931f713422badcd46845e8a">GetCurrentAlternateSetting</a></td></tr>
<tr class="memdesc:af58e940e4931f713422badcd46845e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current alternate interface setting for an interface. Gets the active bAlternateSetting for the current/default interface.  <a href="class_xs_win_usb.html#af58e940e4931f713422badcd46845e8a">More...</a><br /></td></tr>
<tr class="separator:af58e940e4931f713422badcd46845e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61281f53509646905fa81a24d32bf032"><td class="memItemLeft" align="right" valign="top">WinUSB_GetDescriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a61281f53509646905fa81a24d32bf032">GetDescriptor</a></td></tr>
<tr class="memdesc:a61281f53509646905fa81a24d32bf032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested descriptor. This is a synchronous operation.  <a href="class_xs_win_usb.html#a61281f53509646905fa81a24d32bf032">More...</a><br /></td></tr>
<tr class="separator:a61281f53509646905fa81a24d32bf032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f3a168bd238fffab85124fb09ff90d"><td class="memItemLeft" align="right" valign="top">WinUSB_GetOverlappedResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#aa8f3a168bd238fffab85124fb09ff90d">GetOverlappedResult</a></td></tr>
<tr class="memdesc:aa8f3a168bd238fffab85124fb09ff90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the results of an overlapped operation on the specified winUSB handle.  <a href="class_xs_win_usb.html#aa8f3a168bd238fffab85124fb09ff90d">More...</a><br /></td></tr>
<tr class="separator:aa8f3a168bd238fffab85124fb09ff90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188ae7e647433069252f73a98ff89553"><td class="memItemLeft" align="right" valign="top">WinUSB_GetPipePolicy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a188ae7e647433069252f73a98ff89553">GetPipePolicy</a></td></tr>
<tr class="memdesc:a188ae7e647433069252f73a98ff89553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the policy for a specific pipe (endpoint).  <a href="class_xs_win_usb.html#a188ae7e647433069252f73a98ff89553">More...</a><br /></td></tr>
<tr class="separator:a188ae7e647433069252f73a98ff89553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c1c2c03a6c18feca354a477b9ebee1"><td class="memItemLeft" align="right" valign="top">WinUSB_GetPowerPolicy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a96c1c2c03a6c18feca354a477b9ebee1">GetPowerPolicy</a></td></tr>
<tr class="memdesc:a96c1c2c03a6c18feca354a477b9ebee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the power policy for a device.  <a href="class_xs_win_usb.html#a96c1c2c03a6c18feca354a477b9ebee1">More...</a><br /></td></tr>
<tr class="separator:a96c1c2c03a6c18feca354a477b9ebee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b5337b730ce2296bca20d9c8e47d36"><td class="memItemLeft" align="right" valign="top">WinUSB_Initialize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a76b5337b730ce2296bca20d9c8e47d36">Initialize</a></td></tr>
<tr class="memdesc:a76b5337b730ce2296bca20d9c8e47d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates/opens a WinUsb interface handle from the device list.  <a href="class_xs_win_usb.html#a76b5337b730ce2296bca20d9c8e47d36">More...</a><br /></td></tr>
<tr class="separator:a76b5337b730ce2296bca20d9c8e47d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecc85402f46bee3510bfa3e8d7f57ef"><td class="memItemLeft" align="right" valign="top">WinUSB_QueryDeviceInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a6ecc85402f46bee3510bfa3e8d7f57ef">QueryDeviceInformation</a></td></tr>
<tr class="memdesc:a6ecc85402f46bee3510bfa3e8d7f57ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves information about the physical device that is associated with a WinUSB handle.  <a href="class_xs_win_usb.html#a6ecc85402f46bee3510bfa3e8d7f57ef">More...</a><br /></td></tr>
<tr class="separator:a6ecc85402f46bee3510bfa3e8d7f57ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ff55ca589b0e186bf417b5a169af2f"><td class="memItemLeft" align="right" valign="top">WinUSB_QueryInterfaceSettings&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#ad7ff55ca589b0e186bf417b5a169af2f">QueryInterfaceSettings</a></td></tr>
<tr class="memdesc:ad7ff55ca589b0e186bf417b5a169af2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the interface descriptor for the specified alternate interface settings for a particular interface handle.  <a href="class_xs_win_usb.html#ad7ff55ca589b0e186bf417b5a169af2f">More...</a><br /></td></tr>
<tr class="separator:ad7ff55ca589b0e186bf417b5a169af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202eb9725b07bbc9d36c05649f80777e"><td class="memItemLeft" align="right" valign="top">WinUSB_QueryPipe&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a202eb9725b07bbc9d36c05649f80777e">QueryPipe</a></td></tr>
<tr class="memdesc:a202eb9725b07bbc9d36c05649f80777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves information about a pipe that is associated with an interface. The <em>QueryPipe</em> function does not retrieve information about the control pipe.  <a href="class_xs_win_usb.html#a202eb9725b07bbc9d36c05649f80777e">More...</a><br /></td></tr>
<tr class="separator:a202eb9725b07bbc9d36c05649f80777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddaac6ba4e897c934223610e0894188"><td class="memItemLeft" align="right" valign="top">WinUSB_ReadPipe&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a5ddaac6ba4e897c934223610e0894188">ReadPipe</a></td></tr>
<tr class="memdesc:a5ddaac6ba4e897c934223610e0894188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the specified pipe.  <a href="class_xs_win_usb.html#a5ddaac6ba4e897c934223610e0894188">More...</a><br /></td></tr>
<tr class="separator:a5ddaac6ba4e897c934223610e0894188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d200314cf944de351968b5cebf0ca1c"><td class="memItemLeft" align="right" valign="top">WinUSB_ResetPipe&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a4d200314cf944de351968b5cebf0ca1c">ResetPipe</a></td></tr>
<tr class="memdesc:a4d200314cf944de351968b5cebf0ca1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the data toggle and clears the stall condition on a pipe.  <a href="class_xs_win_usb.html#a4d200314cf944de351968b5cebf0ca1c">More...</a><br /></td></tr>
<tr class="separator:a4d200314cf944de351968b5cebf0ca1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737b4064ea87f8d4f25e3b4a9e945d24"><td class="memItemLeft" align="right" valign="top">WinUSB_SetCurrentAlternateSetting&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a737b4064ea87f8d4f25e3b4a9e945d24">SetCurrentAlternateSetting</a></td></tr>
<tr class="memdesc:a737b4064ea87f8d4f25e3b4a9e945d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the alternate setting of an interface. Sets the active <em>bAlternateSetting</em> for the current/default interface.  <a href="class_xs_win_usb.html#a737b4064ea87f8d4f25e3b4a9e945d24">More...</a><br /></td></tr>
<tr class="separator:a737b4064ea87f8d4f25e3b4a9e945d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9e1e1a1868814c8043d824982a15d2"><td class="memItemLeft" align="right" valign="top">WinUSB_SetPipePolicy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#a7c9e1e1a1868814c8043d824982a15d2">SetPipePolicy</a></td></tr>
<tr class="memdesc:a7c9e1e1a1868814c8043d824982a15d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the policy for a specific pipe associated with an endpoint on the device. This is a synchronous operation.  <a href="class_xs_win_usb.html#a7c9e1e1a1868814c8043d824982a15d2">More...</a><br /></td></tr>
<tr class="separator:a7c9e1e1a1868814c8043d824982a15d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61665243a8c9832ea1d60fe84feb9a0"><td class="memItemLeft" align="right" valign="top">WinUSB_SetPowerPolicy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#ab61665243a8c9832ea1d60fe84feb9a0">SetPowerPolicy</a></td></tr>
<tr class="memdesc:ab61665243a8c9832ea1d60fe84feb9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the power policy for a device. The following list summarizes the effects of changes to power management states:  <a href="class_xs_win_usb.html#ab61665243a8c9832ea1d60fe84feb9a0">More...</a><br /></td></tr>
<tr class="separator:ab61665243a8c9832ea1d60fe84feb9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68e3da07b16118f9b455dc6badb262c"><td class="memItemLeft" align="right" valign="top">WinUSB_WritePipe&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_win_usb.html#ad68e3da07b16118f9b455dc6badb262c">WritePipe</a></td></tr>
<tr class="memdesc:ad68e3da07b16118f9b455dc6badb262c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to a pipe.  <a href="class_xs_win_usb.html#ad68e3da07b16118f9b455dc6badb262c">More...</a><br /></td></tr>
<tr class="separator:ad68e3da07b16118f9b455dc6badb262c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for dynamic loading of winusb. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a13dafb21dcad4ededde9d8defdcaa94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13dafb21dcad4ededde9d8defdcaa94a">&#9670;&nbsp;</a></span>AbortPipe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::AbortPipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts all of the pending transfers for a pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeID</td><td>An 8-bit value that consists of a 7-bit address and a direction bit. This parameter corresponds to the <em>bEndpointAddress</em> field in the endpoint descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a0958714bebe476ccf1694eeb76ee3517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0958714bebe476ccf1694eeb76ee3517">&#9670;&nbsp;</a></span>ControlTransfer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::ControlTransfer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits control data over a default control endpoint. A ControlTransfer is never cached. These requests always go directly to the usb device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>A valid winUSB interface handle returned by:<ul>
<li>Initialize</li>
<li>GetAssociatedInterface </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SetupPacket</td><td>The 8-byte setup packet of type WINUSB_SETUP_PACKET. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>A caller-allocated buffer that contains the data to transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferLength</td><td>The number of bytes to transfer, not including the setup packet. This number must be less than or equal to the size, in bytes, of Buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LengthTransferred</td><td>A pointer to a UINT variable that receives the actual number of transferred bytes. If the application does not expect any data to be transferred during the data phase (BufferLength is zero), LengthTransferred can be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Overlapped</td><td>An optional pointer to an OVERLAPPED structure, which is used for asynchronous operations. If this parameter is specified, ControlTransfer immediately returns, and the event is signaled when the operation is complete. If Overlapped is not supplied, the ControlTransfer function transfers data synchronously.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. If an Overlapped member is supplied and the operation succeeds this function returns FALSE and sets last error to ERROR_IO_PENDING. </dd></dl>

</div>
</div>
<a id="a907449242f581fc9e82a926e774482f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907449242f581fc9e82a926e774482f9">&#9670;&nbsp;</a></span>FlushPipe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::FlushPipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards any data that is cached in a pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeID</td><td>An 8-bit value that consists of a 7-bit address and a direction bit. This parameter corresponds to the <em>bEndpointAddress</em> field in the endpoint descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="ae1e5116b15ec3c1ed6a126c4d64e5a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e5116b15ec3c1ed6a126c4d64e5a88">&#9670;&nbsp;</a></span>Free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::Free</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a WinUsb interface handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>Handle to an interface on the device. This handle must be created by a previous call to see <em>Initialize</em> or <em>GetAssociatedInterface</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xs_win_usb.html#ad2de64e0643d7d0aaef813ea41ae41f9" title="Retrieves a handle for an associated interface.">GetAssociatedInterface</a>. </dd></dl>

</div>
</div>
<a id="ad2de64e0643d7d0aaef813ea41ae41f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2de64e0643d7d0aaef813ea41ae41f9">&#9670;&nbsp;</a></span>GetAssociatedInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::GetAssociatedInterface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a handle for an associated interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AssociatedInterfaceIndex</td><td>An index that specifies the associated interface to retrieve. A value of 0 indicates the first associated interface, a value of 1 indicates the second associated interface, and so on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AssociatedInterfaceHandle</td><td>A handle for the associated interface. Callers must pass this interface handle to WinUsb Functions exposed by WinUsb.dll. To close this handle, call Free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="af58e940e4931f713422badcd46845e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58e940e4931f713422badcd46845e8a">&#9670;&nbsp;</a></span>GetCurrentAlternateSetting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::GetCurrentAlternateSetting</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current alternate interface setting for an interface. Gets the active bAlternateSetting for the current/default interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AltSettingNumber</td><td>A pointer to an unsigned character that receives an integer that indicates the current alternate setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a61281f53509646905fa81a24d32bf032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61281f53509646905fa81a24d32bf032">&#9670;&nbsp;</a></span>GetDescriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::GetDescriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the requested descriptor. This is a synchronous operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DescriptorType</td><td>A value that specifies the type of descriptor to return. This parameter corresponds to the bDescriptorType field of a standard device descriptor, whose values are described in the Universal Serial Bus specification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Index</td><td>The descriptor index. For an explanation of the descriptor index, see the Universal Serial Bus specification (www.usb.org). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LanguageID</td><td>A value that specifies the language identifier, if the requested descriptor is a string descriptor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A caller-allocated buffer that receives the requested descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferLength</td><td>The length, in bytes, of Buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LengthTransferred</td><td>The number of bytes that were copied into Buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="aa8f3a168bd238fffab85124fb09ff90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f3a168bd238fffab85124fb09ff90d">&#9670;&nbsp;</a></span>GetOverlappedResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::GetOverlappedResult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the results of an overlapped operation on the specified winUSB handle. </p>
<p>This function is like the Win32 API routine, GetOverlappedResult, with one difference; instead of passing a file handle that is returned from CreateFile, the caller passes an interface handle that is returned from <em>Initialize</em>, or <em>GetAssociatedInterface</em>. The caller can use either API routine, if the appropriate handle is passed. The <em>GetOverlappedResult</em> function extracts the file handle from the interface handle and then calls GetOverlappedResult. The results that are reported by the GetOverlappedResult function are those from the specified handle's last overlapped operation to which the specified standard windows OVERLAPPED structure was provided, and for which the operation's results were pending. A pending operation is indicated when the function that started the operation returns FALSE, and the GetLastError routine returns ERROR_IO_PENDING. When an I/O operation is pending, the function that started the operation resets the hEvent member of the standard windows OVERLAPPED structure to the nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled state. The caller can specify that an event object is manually reset in the standard windows OVERLAPPED structure. If an automatic reset event object is used, the event handle must not be specified in any other wait operation in the interval between starting the overlapped operation and the call to <em>GetOverlappedResult</em>. For example, the event object is sometimes specified in one of the wait routines to wait for the operation to be completed. When the wait routine returns, the system sets an auto-reset event's state to nonsignaled, and a successive call to <em>GetOverlappedResult</em> with the bWait parameter set to TRUE causes the function to be blocked indefinitely. If the bWait parameter is TRUE, GetOverlappedResult determines whether the pending operation has been completed by waiting for the event object to be in the signaled state.</p>
<p>If the hEvent member of the standard windows OVERLAPPED structure is NULL, the system uses the state of the file handle to signal when the operation has been completed. Do not use file handles for this purpose. It is better to use an event object because of the confusion that can occur when multiple concurrent overlapped operations are performed on the same file. In this situation, you cannot know which operation caused the state of the object to be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Overlapped</td><td>A pointer to a standard windows OVERLAPPED structure that was specified when the overlapped operation was started. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lpNumberOfBytesTransferred</td><td>A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bWait</td><td>If this parameter is TRUE, the function does not return until the operation has been completed. If this parameter is FALSE and the operation is still pending, the function returns FALSE and the GetLastError function returns ERROR_IO_INCOMPLETE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a188ae7e647433069252f73a98ff89553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188ae7e647433069252f73a98ff89553">&#9670;&nbsp;</a></span>GetPipePolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::GetPipePolicy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the policy for a specific pipe (endpoint). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeID</td><td>An 8-bit value that consists of a 7-bit address and a direction bit. This parameter corresponds to the bEndpointAddress field in the endpoint descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>A UINT variable that specifies the policy parameter to retrieve. The current value for the policy parameter is retrieved the Value parameter. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ValueLength</td><td>A pointer to the size, in bytes, of the buffer that Value points to. On output, ValueLength receives the size, in bytes, of the data that was copied into the Value buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Value</td><td>A pointer to a buffer that receives the specified pipe policy value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a96c1c2c03a6c18feca354a477b9ebee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c1c2c03a6c18feca354a477b9ebee1">&#9670;&nbsp;</a></span>GetPowerPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::GetPowerPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the power policy for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>A value that specifies the power policy parameter to retrieve in Value. The following table describes symbolic constants that are valid.<ul>
<li>AUTO_SUSPEND (0x81)<ul>
<li>If the caller specifies a power policy of AUTO_SUSPEND, <em>GetPowerPolicy</em> returns the value of the auto suspend policy parameter in the Value parameter.</li>
<li>If Value is TRUE (that is, nonzero), the USB stack suspends the device when no transfers are pending or the only transfers pending are IN transfers on an interrupt or bulk endpoint.</li>
<li>The value of the DefaultIdleState registry value determines the default value of the auto suspend policy parameter.</li>
<li>The Value parameter must point to a UCHAR variable.</li>
</ul>
</li>
<li>SUSPEND_DELAY (0x83)<ul>
<li>If the caller specifies a power policy of SUSPEND_DELAY, <em>GetPowerPolicy</em> returns the value of the suspend delay policy parameter in Value.</li>
<li>The suspend delay policy parameter specifies the minimum amount of time, in milliseconds, that the driver must wait after any transfer before it can suspend the device.</li>
<li>Value must point to a UINT variable.</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ValueLength</td><td>A pointer to the size of the buffer that Value. On output, ValueLength receives the size of the data that was copied into the Value buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Value</td><td>A buffer that receives the specified power policy parameter. For more information, see PolicyType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a76b5337b730ce2296bca20d9c8e47d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b5337b730ce2296bca20d9c8e47d36">&#9670;&nbsp;</a></span>Initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::Initialize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates/opens a WinUsb interface handle from the device list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">InterfaceHandle</td><td>Receives a handle configured to the first (default) interface on the device. This handle is required by other WinUsb routines that perform operations on the default interface. The handle is opaque. To release this handle, call the <em>Free</em> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DevInfo</td><td>The device list element to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a6ecc85402f46bee3510bfa3e8d7f57ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecc85402f46bee3510bfa3e8d7f57ef">&#9670;&nbsp;</a></span>QueryDeviceInformation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::QueryDeviceInformation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves information about the physical device that is associated with a WinUSB handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InformationType</td><td>A value that specifies which interface information value to retrieve. On input, InformationType must have the following value: DEVICE_SPEED (0x01). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BufferLength</td><td>The maximum number of bytes to read. This number must be less than or equal to the size, in bytes, of Buffer. On output, BufferLength is set to the actual number of bytes that were copied into Buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Buffer</td><td>A caller-allocated buffer that receives the requested value. On output, Buffer indicates the device speed: (0x01) low/full speed device. (0x03) high speed device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="ad7ff55ca589b0e186bf417b5a169af2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ff55ca589b0e186bf417b5a169af2f">&#9670;&nbsp;</a></span>QueryInterfaceSettings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::QueryInterfaceSettings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the interface descriptor for the specified alternate interface settings for a particular interface handle. </p>
<p>The <em>QueryInterfaceSettings</em> call searches the current/default interface array for the alternate interface specified by the caller in the <em>AltSettingIndex</em>. If the specified alternate interface is found, the function populates the caller-allocated USB_INTERFACE_DESCRIPTOR structure. If the specified alternate interface is not found, then the call fails with the ERROR_NO_MORE_ITEMS code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AltSettingIndex</td><td>A value that indicates which alternate setting index to return. A value of 0 indicates the first alternate setting, a value of 1 indicates the second alternate setting, and so on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UsbAltInterfaceDescriptor</td><td>A pointer to a caller-allocated USB_INTERFACE_DESCRIPTOR structure that contains information about the interface that AltSettingNumber specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a202eb9725b07bbc9d36c05649f80777e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202eb9725b07bbc9d36c05649f80777e">&#9670;&nbsp;</a></span>QueryPipe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::QueryPipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves information about a pipe that is associated with an interface. The <em>QueryPipe</em> function does not retrieve information about the control pipe. </p>
<p>Each interface on the USB device can have multiple endpoints. To communicate with each of these endpoints, the bus driver creates pipes for each endpoint on the interface. The pipe indices are zero-based. Therefore for n number of endpoints, the pipes' indices are set from n-1. <em>QueryPipe</em> parses the configuration descriptor to get the interface specified by the caller. It searches the interface descriptor for the endpoint descriptor associated with the caller-specified pipe. If the endpoint is found, the function populates the caller-allocated WINUSB_PIPE_INFORMATION structure with information from the endpoint descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AltSettingNumber</td><td>A value that specifies the alternate interface to return the information for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeIndex</td><td>A value that specifies the pipe to return information about. This value is not the same as the bEndpointAddress field in the endpoint descriptor. A PipeIndex value of 0 signifies the first endpoint that is associated with the interface, a value of 1 signifies the second endpoint, and so on. PipeIndex must be less than the value in the bNumEndpoints field of the interface descriptor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PipeInformation</td><td>A pointer, on output, to a caller-allocated WINUSB_PIPE_INFORMATION structure that contains pipe information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a5ddaac6ba4e897c934223610e0894188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddaac6ba4e897c934223610e0894188">&#9670;&nbsp;</a></span>ReadPipe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::ReadPipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the specified pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeID</td><td>An 8-bit value that consists of a 7-bit address and a direction bit. This parameter corresponds to the bEndpointAddress field in the endpoint descriptor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>A caller-allocated buffer that receives the data that is read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferLength</td><td>The maximum number of bytes to read. This number must be less than or equal to the size, in bytes, of Buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LengthTransferred</td><td>A pointer to a UINT variable that receives the actual number of bytes that were copied into Buffer. For more information, see Remarks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Overlapped</td><td>An optional pointer to an overlapped structure for asynchronous operations. This can be a KOVL_HANDLE or a pointer to a standard windows OVERLAPPED structure. If this parameter is specified, <em>ReadPipe</em> returns immediately rather than waiting synchronously for the operation to complete before returning. An event is signaled when the operation is complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a4d200314cf944de351968b5cebf0ca1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d200314cf944de351968b5cebf0ca1c">&#9670;&nbsp;</a></span>ResetPipe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::ResetPipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the data toggle and clears the stall condition on a pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeID</td><td>An 8-bit value that consists of a 7-bit address and a direction bit. This parameter corresponds to the <em>bEndpointAddress</em> field in the endpoint descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="a737b4064ea87f8d4f25e3b4a9e945d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737b4064ea87f8d4f25e3b4a9e945d24">&#9670;&nbsp;</a></span>SetCurrentAlternateSetting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::SetCurrentAlternateSetting</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the alternate setting of an interface. Sets the active <em>bAlternateSetting</em> for the current/default interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AltSettingNumber</td><td>The value that is contained in the <em>bAlternateSetting</em> member of the USB_INTERFACE_DESCRIPTOR structure. This structure can be populated by the <em>QueryInterfaceSettings</em> routine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_xs_win_usb.html#ad7ff55ca589b0e186bf417b5a169af2f" title="Retrieves the interface descriptor for the specified alternate interface settings for a particular in...">QueryInterfaceSettings</a> </dd></dl>

</div>
</div>
<a id="a7c9e1e1a1868814c8043d824982a15d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9e1e1a1868814c8043d824982a15d2">&#9670;&nbsp;</a></span>SetPipePolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::SetPipePolicy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the policy for a specific pipe associated with an endpoint on the device. This is a synchronous operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeID</td><td>An 8-bit value that consists of a 7-bit address and a direction bit. This parameter corresponds to the bEndpointAddress field in the endpoint descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>A UINT variable that specifies the policy parameter to change. The Value parameter contains the new value for the policy parameter. See the remarks section for information about each of the pipe policies and the resulting behavior. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ValueLength</td><td>The size, in bytes, of the buffer at Value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Value</td><td>The new value for the policy parameter that PolicyType specifies. The size of this input parameter depends on the policy to change. For information about the size of this parameter, see the description of the PolicyType parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The following list describes symbolic constants for <em>PolicyType</em> </dd></dl>
<ul>
<li>SHORT_PACKET_TERMINATE (0x01)<ul>
<li>The default value is FALSE.</li>
<li>To enable SHORT_PACKET_TERMINATE, in Value pass the address of a caller-allocated UCHAR variable set to TRUE (nonzero).</li>
<li>Enabling SHORT_PACKET_TERMINATE causes the driver to send a zero-length packet at the end of every write request to the host controller.</li>
</ul>
</li>
<li>AUTO_CLEAR_STALL (0x02)<ul>
<li>The default value is FALSE. To enable AUTO_CLEAR_STALL, in Value pass the address of a caller-allocated UCHAR variable set to TRUE (nonzero).</li>
<li>Enabling AUTO_CLEAR_STALL causes winUSB to reset the pipe in order to automatically clear the stall condition. Data continues to flow on the bulk and interrupt IN endpoints again as soon as a new or a queued transfer arrives on the endpoint. This policy parameter does not affect control pipes.</li>
<li>Disabling AUTO_CLEAR_STALL causes all transfers (that arrive to the endpoint after the stalled transfer) to fail until the caller manually resets the endpoint's pipe by calling ResetPipe.</li>
</ul>
</li>
<li>PIPE_TRANSFER_TIMEOUT (0x03)<ul>
<li>The default value is zero. To set a time-out value, in Value pass the address of a caller-allocated UINT variable that contains the time-out interval.</li>
<li>The PIPE_TRANSFER_TIMEOUT value specifies the time-out interval, in milliseconds. The host controller cancels transfers that do not complete within the specified time-out interval.</li>
<li>A value of zero (default) indicates that transfers do not time out because the host controller never cancels the transfer.</li>
</ul>
</li>
<li>IGNORE_SHORT_PACKETS (0x04)<ul>
<li>The default value is FALSE. To enable IGNORE_SHORT_PACKETS, in Value pass the address of a caller-allocated UCHAR variable set to TRUE (nonzero).</li>
<li>Enabling IGNORE_SHORT_PACKETS causes the host controller to not complete a read operation after it receives a short packet. Instead, the host controller completes the operation only after the host has read the specified number of bytes.</li>
<li>Disabling IGNORE_SHORT_PACKETS causes the host controller to complete a read operation when either the host has read the specified number of bytes or the host has received a short packet.</li>
</ul>
</li>
<li>ALLOW_PARTIAL_READS (0x05)<ul>
<li>The default value is TRUE (nonzero). To disable ALLOW_PARTIAL_READS, in Value pass the address of a caller-allocated UCHAR variable set to FALSE (zero).</li>
<li>Disabling ALLOW_PARTIAL_READS causes the read requests to fail whenever the device returns more data (on bulk and interrupt IN endpoints) than the caller requested.</li>
<li>Enabling ALLOW_PARTIAL_READS causes winUSB to save or discard the extra data when the device returns more data (on bulk and interrupt IN endpoints) than the caller requested. This behavior is defined by setting the AUTO_FLUSH value.</li>
</ul>
</li>
<li>AUTO_FLUSH (0x06)<ul>
<li>The default value is FALSE (zero). To enable AUTO_FLUSH, in Value pass the address of a caller-allocated UCHAR variable set to TRUE (nonzero).</li>
<li>AUTO_FLUSH must be used with ALLOW_PARTIAL_READS enabled. If ALLOW_PARTIAL_READS is TRUE, the value of AUTO_FLUSH determines the action taken by winUSB when the device returns more data than the caller requested.</li>
<li>Disabling ALLOW_PARTIAL_READS causes winUSB to ignore the AUTO_FLUSH value.</li>
<li>Disabling AUTO_FLUSH with ALLOW_PARTIAL_READS enabled causes winUSB to save the extra data, add the data to the beginning of the caller's next read request, and send it to the caller in the next read operation.</li>
<li>Enabling AUTO_FLUSH with ALLOW_PARTIAL_READS enabled causes winUSB to discard the extra data remaining from the read request.</li>
</ul>
</li>
<li>RAW_IO (0x07)<ul>
<li>The default value is FALSE (zero). To enable RAW_IO, in Value pass the address of a caller-allocated UCHAR variable set to TRUE (nonzero).</li>
<li>Enabling RAW_IO causes winUSB to send data directly to the USB driver stack, bypassing winUSB's queuing and error handling mechanism.</li>
<li>The buffers that are passed to <em>ReadPipe</em> must be configured by the caller as follows:</li>
<li>The buffer length must be a multiple of the maximum endpoint packet size.</li>
<li>The length must be less than or equal to the value of MAXIMUM_TRANSFER_SIZE retrieved by GetPipePolicy.</li>
<li>Disabling RAW_IO (FALSE) does not impose any restriction on the buffers that are passed to <em>ReadPipe</em>.</li>
</ul>
</li>
<li>RESET_PIPE_ON_RESUME (0x09)<ul>
<li>The default value is FALSE (zero). To enable RESET_PIPE_ON_RESUME, in Value pass the address of a caller-allocated UCHAR variable set to TRUE (nonzero).</li>
<li>TRUE (or a nonzero value) indicates that on resume from suspend, winUSB resets the endpoint before it allows the caller to send new requests to the endpoint.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="ab61665243a8c9832ea1d60fe84feb9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61665243a8c9832ea1d60fe84feb9a0">&#9670;&nbsp;</a></span>SetPowerPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::SetPowerPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the power policy for a device. The following list summarizes the effects of changes to power management states: </p>
<ul>
<li>All pipe handles, interface handles, locks, and alternate settings are preserved across power management events.</li>
<li>Any transfers that are in progress are suspended when a device transfers to a low power state, and they are resumed when the device is restored to a working state.</li>
<li>The device and system must be in a working state before the client can restore a device-specific configuration. Clients can determine whether the device and system are in a working state from the WM_POWERBROADCAST message.</li>
<li>The client can indicate that an interface is idle by calling <em>SetPowerPolicy</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PolicyType</td><td>A value that specifies the power policy to set. The following table describes symbolic constants.<ul>
<li>AUTO_SUSPEND (0x81)<ul>
<li>Specifies the auto-suspend policy type; the power policy parameter must be specified by the caller in the Value parameter.</li>
<li>For auto-suspend, the Value parameter must point to a UCHAR variable.</li>
<li>If Value is TRUE (nonzero), the USB stack suspends the device if the device is idle. A device is idle if there are no transfers pending, or if the only pending transfers are IN transfers to interrupt or bulk endpoints.</li>
<li>The default value is determined by the value set in the DefaultIdleState registry setting. By default, this value is TRUE.</li>
</ul>
</li>
<li>SUSPEND_DELAY (0x83)<ul>
<li>Specifies the suspend-delay policy type; the power policy parameter must be specified by the caller in the Value parameter.</li>
<li>For suspend-delay, Value must point to a UINT variable.</li>
<li>Value specifies the minimum amount of time, in milliseconds, that the driver must wait post transfer before it can suspend the device.</li>
<li>The default value is determined by the value set in the DefaultIdleTimeout registry setting. By default, this value is five seconds.</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ValueLength</td><td>The size, in bytes, of the buffer at Value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Value</td><td>The new value for the power policy parameter. Data type and value for Value depends on the type of power policy passed in PolicyType. For more information, see PolicyType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
<a id="ad68e3da07b16118f9b455dc6badb262c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68e3da07b16118f9b455dc6badb262c">&#9670;&nbsp;</a></span>WritePipe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL XsWinUsb::WritePipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to a pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">InterfaceHandle</td><td>An initialized usb handle, see <em>Initialize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PipeID</td><td>An 8-bit value that consists of a 7-bit address and a direction bit. This parameter corresponds to the bEndpointAddress field in the endpoint descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>A caller-allocated buffer the data is written from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BufferLength</td><td>The maximum number of bytes to write. This number must be less than or equal to the size, in bytes, of Buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LengthTransferred</td><td>A pointer to a UINT variable that receives the actual number of bytes that were transferred from Buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Overlapped</td><td>An optional pointer to an overlapped structure for asynchronous operations. This can be a KOVL_HANDLE or a pointer to a standard windows OVERLAPPED structure. If this parameter is specified, <em>WritePipe</em> returns immediately rather than waiting synchronously for the operation to complete before returning. An event is signaled when the operation is complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, TRUE. Otherwise FALSE. Use GetLastError() to get extended error information. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_xs_win_usb.html">XsWinUsb</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
