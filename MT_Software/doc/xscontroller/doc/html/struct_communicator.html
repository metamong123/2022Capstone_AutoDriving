<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XsController: Communicator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xsenslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XsController
   &#160;<span id="projectnumber">2021.4.0</span>
   </div>
   <div id="projectbrief">Xsens Device API Public Communication Objects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_communicator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="struct_communicator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Communicator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A base struct for a communication interface.  
 <a href="struct_communicator.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Communicator:</div>
<div class="dyncontent">
<div class="center"><img src="struct_communicator__inherit__graph.png" border="0" usemap="#_communicator_inherit__map" alt="Inheritance graph"/></div>
<map name="_communicator_inherit__map" id="_communicator_inherit__map">
<area shape="rect" title="A base struct for a communication interface." alt="" coords="213,229,331,256"/>
<area shape="rect" href="class_device_communicator.html" title="A class that is used for the communcation with a device." alt="" coords="97,304,260,331"/>
<area shape="rect" href="class_mtb_file_communicator.html" title="A class that is used for the communcation with a mtb file." alt="" coords="285,304,449,331"/>
<area shape="rect" href="class_callback_manager_xda.html" title="Class that delegates callbacks to registered XsCallbackHandlerItems." alt="" coords="193,155,351,181"/>
<area shape="rect" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API." alt="" coords="225,80,319,107"/>
<area shape="rect" href="struct_xs_callback_plain_c.html" title="Structure that contains callback functions for the Xsens Device API." alt="" coords="205,5,339,32"/>
<area shape="rect" href="class_serial_communicator.html" title="A class that uses serial communication." alt="" coords="101,379,256,405"/>
<area shape="rect" href="class_proxy_communicator.html" title=" " alt="" coords="5,453,160,480"/>
<area shape="rect" href="class_serial_port_communicator.html" title="A class that uses serial port to communicate." alt="" coords="184,453,365,480"/>
<area shape="rect" href="class_usb_communicator.html" title="A class that uses USB to communicate." alt="" coords="203,528,346,555"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator_1_1_deleter.html">Deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The communicator deleter.  <a href="struct_communicator_1_1_deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b38fd3197a742fdb2ff68ac4fcd4b0f"><td class="memTemplParams" colspan="2"><a id="a0b38fd3197a742fdb2ff68ac4fcd4b0f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b38fd3197a742fdb2ff68ac4fcd4b0f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a> = std::unique_ptr&lt; T, <a class="el" href="struct_communicator_1_1_deleter.html">Deleter</a> &gt;</td></tr>
<tr class="memdesc:a0b38fd3197a742fdb2ff68ac4fcd4b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes of UniquePtr&lt;T&gt; <br /></td></tr>
<tr class="separator:a0b38fd3197a742fdb2ff68ac4fcd4b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af732adc9e6e84804da996b715c83c803"><td class="memItemLeft" align="right" valign="top"><a id="af732adc9e6e84804da996b715c83c803"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#af732adc9e6e84804da996b715c83c803">Communicator</a> (void)</td></tr>
<tr class="memdesc:af732adc9e6e84804da996b715c83c803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, creates some management objects and clears the rest by calling initialize() <br /></td></tr>
<tr class="separator:af732adc9e6e84804da996b715c83c803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae4ff2e76a332cb0106c373f342bc79"><td class="memItemLeft" align="right" valign="top"><a id="adae4ff2e76a332cb0106c373f342bc79"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#adae4ff2e76a332cb0106c373f342bc79">abortLoadLogFile</a> ()=0</td></tr>
<tr class="memdesc:adae4ff2e76a332cb0106c373f342bc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts loading a logfile. <br /></td></tr>
<tr class="separator:adae4ff2e76a332cb0106c373f342bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9133a96d8f5d3f602981bcf1d8b74ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab9133a96d8f5d3f602981bcf1d8b74ac">addProtocolHandler</a> (<a class="el" href="class_i_protocol_handler.html">IProtocolHandler</a> *handler)</td></tr>
<tr class="memdesc:ab9133a96d8f5d3f602981bcf1d8b74ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a protocol handler.  <a href="struct_communicator.html#ab9133a96d8f5d3f602981bcf1d8b74ac">More...</a><br /></td></tr>
<tr class="separator:ab9133a96d8f5d3f602981bcf1d8b74ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7cb30f37dd08db96c76ab3c86e014b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a5f7cb30f37dd08db96c76ab3c86e014b">addReplyObject</a> (<a class="el" href="class_reply_object.html">ReplyObject</a> *obj)</td></tr>
<tr class="memdesc:a5f7cb30f37dd08db96c76ab3c86e014b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom <a class="el" href="class_reply_object.html" title="Abstract reply object. Blocks on a semaphore when requesting the message until the message has been s...">ReplyObject</a>.  <a href="struct_communicator.html#a5f7cb30f37dd08db96c76ab3c86e014b">More...</a><br /></td></tr>
<tr class="separator:a5f7cb30f37dd08db96c76ab3c86e014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83d20bf72bcfc7df91564159d2a947"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aba83d20bf72bcfc7df91564159d2a947">addReplyObject</a> (uint8_t mid)</td></tr>
<tr class="memdesc:aba83d20bf72bcfc7df91564159d2a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="class_mid_reply_object.html" title="Reply object that only checks the message identifier.">MidReplyObject</a>.  <a href="struct_communicator.html#aba83d20bf72bcfc7df91564159d2a947">More...</a><br /></td></tr>
<tr class="separator:aba83d20bf72bcfc7df91564159d2a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331d3bc7f8845fd6d8b62a64dde8f9a5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a331d3bc7f8845fd6d8b62a64dde8f9a5">addReplyObject</a> (uint8_t mid, XsSize offset, XsSize size, uint8_t const *data)</td></tr>
<tr class="memdesc:a331d3bc7f8845fd6d8b62a64dde8f9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="class_mid_and_data_reply_object.html" title="Reply object that checks the message identifier and data in the data field.">MidAndDataReplyObject</a>.  <a href="struct_communicator.html#a331d3bc7f8845fd6d8b62a64dde8f9a5">More...</a><br /></td></tr>
<tr class="separator:a331d3bc7f8845fd6d8b62a64dde8f9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e4963e852857d8e919978b5384ea3b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a44e4963e852857d8e919978b5384ea3b">allowReprocessing</a> () const</td></tr>
<tr class="separator:a44e4963e852857d8e919978b5384ea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c99be8ee160af0e79888622b9bd44b"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#af4c99be8ee160af0e79888622b9bd44b">childDeviceCount</a> () const</td></tr>
<tr class="separator:af4c99be8ee160af0e79888622b9bd44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bb7b535e5fbcb2657a1aa09d0ccd9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a40bb7b535e5fbcb2657a1aa09d0ccd9e">closeLogFile</a> ()=0</td></tr>
<tr class="memdesc:a40bb7b535e5fbcb2657a1aa09d0ccd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the log file.  <a href="struct_communicator.html#a40bb7b535e5fbcb2657a1aa09d0ccd9e">More...</a><br /></td></tr>
<tr class="separator:a40bb7b535e5fbcb2657a1aa09d0ccd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7089176f27ed750ba368d0569c633cfa"><td class="memItemLeft" align="right" valign="top"><a id="a7089176f27ed750ba368d0569c633cfa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7089176f27ed750ba368d0569c633cfa">closePort</a> ()=0</td></tr>
<tr class="memdesc:a7089176f27ed750ba368d0569c633cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the open port. <br /></td></tr>
<tr class="separator:a7089176f27ed750ba368d0569c633cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c7d171bbc01a004f50b414621cb7e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a20c7d171bbc01a004f50b414621cb7e8">defaultTimeout</a> () const</td></tr>
<tr class="separator:a20c7d171bbc01a004f50b414621cb7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d72b1fa5445ee561db946408dfc924f"><td class="memItemLeft" align="right" valign="top"><a id="a0d72b1fa5445ee561db946408dfc924f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a0d72b1fa5445ee561db946408dfc924f">destroy</a> ()</td></tr>
<tr class="memdesc:a0d72b1fa5445ee561db946408dfc924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the communicator. <br /></td></tr>
<tr class="separator:a0d72b1fa5445ee561db946408dfc924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adcf4eecb610758e57efeddd79e100f"><td class="memItemLeft" align="right" valign="top"><a id="a9adcf4eecb610758e57efeddd79e100f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a9adcf4eecb610758e57efeddd79e100f">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a9adcf4eecb610758e57efeddd79e100f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a9adcf4eecb610758e57efeddd79e100f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cb436aa72f757dfec1968cb50d69dc"><td class="memItemLeft" align="right" valign="top"><a id="a54cb436aa72f757dfec1968cb50d69dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a54cb436aa72f757dfec1968cb50d69dc">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message, uint32_t timeout)</td></tr>
<tr class="memdesc:a54cb436aa72f757dfec1968cb50d69dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a54cb436aa72f757dfec1968cb50d69dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea360b8a63d1f9325b9ff01fffd0d8"><td class="memItemLeft" align="right" valign="top"><a id="a49ea360b8a63d1f9325b9ff01fffd0d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a49ea360b8a63d1f9325b9ff01fffd0d8">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv)</td></tr>
<tr class="memdesc:a49ea360b8a63d1f9325b9ff01fffd0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a49ea360b8a63d1f9325b9ff01fffd0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c7243e499160cc244138727cc9fc3c"><td class="memItemLeft" align="right" valign="top"><a id="ab5c7243e499160cc244138727cc9fc3c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab5c7243e499160cc244138727cc9fc3c">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv, uint32_t timeout)=0</td></tr>
<tr class="memdesc:ab5c7243e499160cc244138727cc9fc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:ab5c7243e499160cc244138727cc9fc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efdbacaabc4b399a3423011e6a3ef4b"><td class="memItemLeft" align="right" valign="top"><a id="a1efdbacaabc4b399a3423011e6a3ef4b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a1efdbacaabc4b399a3423011e6a3ef4b">flushPort</a> ()=0</td></tr>
<tr class="memdesc:a1efdbacaabc4b399a3423011e6a3ef4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all remaining data on the open port. <br /></td></tr>
<tr class="separator:a1efdbacaabc4b399a3423011e6a3ef4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bae91c2bbbfd74e56ff0ee1bdb27d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ad8bae91c2bbbfd74e56ff0ee1bdb27d5">getDeviceId</a> ()=0</td></tr>
<tr class="memdesc:ad8bae91c2bbbfd74e56ff0ee1bdb27d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to get device ID.  <a href="struct_communicator.html#ad8bae91c2bbbfd74e56ff0ee1bdb27d5">More...</a><br /></td></tr>
<tr class="separator:ad8bae91c2bbbfd74e56ff0ee1bdb27d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e183d2fdad136d39d96bb69da118dc4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7e183d2fdad136d39d96bb69da118dc4">gotoConfig</a> (bool detectRs485=false)=0</td></tr>
<tr class="memdesc:a7e183d2fdad136d39d96bb69da118dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to go to config mode.  <a href="struct_communicator.html#a7e183d2fdad136d39d96bb69da118dc4">More...</a><br /></td></tr>
<tr class="separator:a7e183d2fdad136d39d96bb69da118dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fecb5f975db28879d7e8cdb600ddc3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a29fecb5f975db28879d7e8cdb600ddc3">gotoMeasurement</a> ()=0</td></tr>
<tr class="memdesc:a29fecb5f975db28879d7e8cdb600ddc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to go to measurement mode.  <a href="struct_communicator.html#a29fecb5f975db28879d7e8cdb600ddc3">More...</a><br /></td></tr>
<tr class="separator:a29fecb5f975db28879d7e8cdb600ddc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148c456f7ef9c9c2fb8c7ef4ee259e35"><td class="memItemLeft" align="right" valign="top"><a id="a148c456f7ef9c9c2fb8c7ef4ee259e35"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a148c456f7ef9c9c2fb8c7ef4ee259e35">handleMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a148c456f7ef9c9c2fb8c7ef4ee259e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a <em>message</em>. <br /></td></tr>
<tr class="separator:a148c456f7ef9c9c2fb8c7ef4ee259e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f838f1f5da8b3ec5cba61a47d6ee2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a89f838f1f5da8b3ec5cba61a47d6ee2a">hasProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type) const</td></tr>
<tr class="separator:a89f838f1f5da8b3ec5cba61a47d6ee2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5f09d90d85fdbe5d7ad7688b6c3bcd"><td class="memItemLeft" align="right" valign="top"><a id="aea5f09d90d85fdbe5d7ad7688b6c3bcd"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aea5f09d90d85fdbe5d7ad7688b6c3bcd">isDockedAt</a> (<a class="el" href="struct_communicator.html">Communicator</a> *other) const =0</td></tr>
<tr class="memdesc:aea5f09d90d85fdbe5d7ad7688b6c3bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>other</em> device is docked at this device. <br /></td></tr>
<tr class="separator:aea5f09d90d85fdbe5d7ad7688b6c3bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecf3bf1cbd0f42de59123450833d680"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aeecf3bf1cbd0f42de59123450833d680">isLoadLogFileInProgress</a> () const</td></tr>
<tr class="separator:aeecf3bf1cbd0f42de59123450833d680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3961efd576ab1736b51b6675a28fb3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a5e3961efd576ab1736b51b6675a28fb3">isPortOpen</a> () const =0</td></tr>
<tr class="separator:a5e3961efd576ab1736b51b6675a28fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b11375cf627734ba69e619691fba31"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a68b11375cf627734ba69e619691fba31">isReadingFromFile</a> () const =0</td></tr>
<tr class="separator:a68b11375cf627734ba69e619691fba31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b1f15cfc16c51f839f0fc5f57060a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">lastResult</a> () const</td></tr>
<tr class="memdesc:a01b1f15cfc16c51f839f0fc5f57060a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">More...</a><br /></td></tr>
<tr class="separator:a01b1f15cfc16c51f839f0fc5f57060a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace27546fc55e56bc861e1c29bf7955a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ace27546fc55e56bc861e1c29bf7955a7">lastResultText</a> () const</td></tr>
<tr class="memdesc:ace27546fc55e56bc861e1c29bf7955a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accompanying error text for the value returned by <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6" title="Get the result value of the last operation.">lastResult()</a> It may provide situation-specific information instead.  <a href="struct_communicator.html#ace27546fc55e56bc861e1c29bf7955a7">More...</a><br /></td></tr>
<tr class="separator:ace27546fc55e56bc861e1c29bf7955a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30d1ce853cd5cea8326876109ad73bb"><td class="memItemLeft" align="right" valign="top"><a id="aa30d1ce853cd5cea8326876109ad73bb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aa30d1ce853cd5cea8326876109ad73bb">loadLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *device)=0</td></tr>
<tr class="memdesc:aa30d1ce853cd5cea8326876109ad73bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a complete logfile. <br /></td></tr>
<tr class="separator:aa30d1ce853cd5cea8326876109ad73bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388a1ae810ecad38c93ca03de5be1c9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a388a1ae810ecad38c93ca03de5be1c9d">logFileDate</a> () const =0</td></tr>
<tr class="separator:a388a1ae810ecad38c93ca03de5be1c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6288d0041d1116a063f1d92f4ce4a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a2b6288d0041d1116a063f1d92f4ce4a9">logFileName</a> () const =0</td></tr>
<tr class="separator:a2b6288d0041d1116a063f1d92f4ce4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a49e9a8ff16018c5b8d5631c63e97"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a1d2a49e9a8ff16018c5b8d5631c63e97">logFileReadPosition</a> () const =0</td></tr>
<tr class="separator:a1d2a49e9a8ff16018c5b8d5631c63e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2215784fb1364868b89ce60518c0c1e3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a2215784fb1364868b89ce60518c0c1e3">logFileSize</a> () const =0</td></tr>
<tr class="separator:a2215784fb1364868b89ce60518c0c1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c63e78f350c54778c4fd31924ac92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a849c63e78f350c54778c4fd31924ac92">masterDeviceId</a> () const</td></tr>
<tr class="separator:a849c63e78f350c54778c4fd31924ac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab869c9bf1289e05b4289060cb3d113b2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab869c9bf1289e05b4289060cb3d113b2">openLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)=0</td></tr>
<tr class="memdesc:ab869c9bf1289e05b4289060cb3d113b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the log file `.  <a href="struct_communicator.html#ab869c9bf1289e05b4289060cb3d113b2">More...</a><br /></td></tr>
<tr class="separator:ab869c9bf1289e05b4289060cb3d113b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa111ea807518c31210865dc0343a3b22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aa111ea807518c31210865dc0343a3b22">openPort</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;<a class="el" href="struct_communicator.html#a1a4ba050c31e70abd4565dd505d6387c">portInfo</a>, <a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a> stage=OPS_Full, bool detectRs485=false)=0</td></tr>
<tr class="memdesc:aa111ea807518c31210865dc0343a3b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a port.  <a href="struct_communicator.html#aa111ea807518c31210865dc0343a3b22">More...</a><br /></td></tr>
<tr class="separator:aa111ea807518c31210865dc0343a3b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ba050c31e70abd4565dd505d6387c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_port_info.html">XsPortInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a1a4ba050c31e70abd4565dd505d6387c">portInfo</a> () const =0</td></tr>
<tr class="separator:a1a4ba050c31e70abd4565dd505d6387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692484e8c4f7a588f49a3cb1123a962f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a692484e8c4f7a588f49a3cb1123a962f">readMessage</a> (uint8_t msgId=0)=0</td></tr>
<tr class="memdesc:a692484e8c4f7a588f49a3cb1123a962f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from the open file.  <a href="struct_communicator.html#a692484e8c4f7a588f49a3cb1123a962f">More...</a><br /></td></tr>
<tr class="separator:a692484e8c4f7a588f49a3cb1123a962f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2651a48958605e80d6e3e4519f438d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#af2651a48958605e80d6e3e4519f438d6">readMessageFromStartOfFile</a> (uint8_t msgId, int maxMsgs=0)=0</td></tr>
<tr class="memdesc:af2651a48958605e80d6e3e4519f438d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from the start of the open file.  <a href="struct_communicator.html#af2651a48958605e80d6e3e4519f438d6">More...</a><br /></td></tr>
<tr class="separator:af2651a48958605e80d6e3e4519f438d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba8fe953887ceea6a42ae27f80d58d7"><td class="memItemLeft" align="right" valign="top">virtual std::deque&lt; <a class="el" href="struct_xs_message.html">XsMessage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aeba8fe953887ceea6a42ae27f80d58d7">readMessagesFromStartOfFile</a> (uint8_t msgId, int maxMsgs=0)=0</td></tr>
<tr class="memdesc:aeba8fe953887ceea6a42ae27f80d58d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple similar messages from the start of the open file.  <a href="struct_communicator.html#aeba8fe953887ceea6a42ae27f80d58d7">More...</a><br /></td></tr>
<tr class="separator:aeba8fe953887ceea6a42ae27f80d58d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef923814a0a92a47cd747f688fd5aac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7ef923814a0a92a47cd747f688fd5aac">removeProtocolHandler</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type)</td></tr>
<tr class="memdesc:a7ef923814a0a92a47cd747f688fd5aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a protocol handler.  <a href="struct_communicator.html#a7ef923814a0a92a47cd747f688fd5aac">More...</a><br /></td></tr>
<tr class="separator:a7ef923814a0a92a47cd747f688fd5aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96111aa187a632a62242b5d3dd08787"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aa96111aa187a632a62242b5d3dd08787">reopenPort</a> (<a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a> stage=OPS_Full, bool skipDeviceIdCheck=false)=0</td></tr>
<tr class="memdesc:aa96111aa187a632a62242b5d3dd08787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopens the port.  <a href="struct_communicator.html#aa96111aa187a632a62242b5d3dd08787">More...</a><br /></td></tr>
<tr class="separator:aa96111aa187a632a62242b5d3dd08787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf0fb26ffe0677d133ee15b2c630f51"><td class="memItemLeft" align="right" valign="top"><a id="aacf0fb26ffe0677d133ee15b2c630f51"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aacf0fb26ffe0677d133ee15b2c630f51">resetLogFileReadPosition</a> (void)=0</td></tr>
<tr class="memdesc:aacf0fb26ffe0677d133ee15b2c630f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the logfile read position. <br /></td></tr>
<tr class="separator:aacf0fb26ffe0677d133ee15b2c630f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0efda63671e15cc3f4b8862d8827610"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab0efda63671e15cc3f4b8862d8827610">sanityCheck</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const &amp;msg) const</td></tr>
<tr class="memdesc:ab0efda63671e15cc3f4b8862d8827610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a sanity check on a potential message.  <a href="struct_communicator.html#ab0efda63671e15cc3f4b8862d8827610">More...</a><br /></td></tr>
<tr class="separator:ab0efda63671e15cc3f4b8862d8827610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e07bb6858d2e4a83ccfc7591b1795"><td class="memItemLeft" align="right" valign="top"><a id="a319e07bb6858d2e4a83ccfc7591b1795"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a319e07bb6858d2e4a83ccfc7591b1795">scheduleClosePort</a> ()</td></tr>
<tr class="memdesc:a319e07bb6858d2e4a83ccfc7591b1795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules to close the open port. <br /></td></tr>
<tr class="separator:a319e07bb6858d2e4a83ccfc7591b1795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aebec75db10bb2ddf1e8d677b3adcd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a96aebec75db10bb2ddf1e8d677b3adcd">setCredentials</a> (<a class="el" href="struct_xs_string.html">XsString</a> const &amp;id, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;key)</td></tr>
<tr class="memdesc:a96aebec75db10bb2ddf1e8d677b3adcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the credentials required for using the device.  <a href="struct_communicator.html#a96aebec75db10bb2ddf1e8d677b3adcd">More...</a><br /></td></tr>
<tr class="separator:a96aebec75db10bb2ddf1e8d677b3adcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8a600fa59679e03debe2e6825a2bc4"><td class="memItemLeft" align="right" valign="top"><a id="a7e8a600fa59679e03debe2e6825a2bc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7e8a600fa59679e03debe2e6825a2bc4">setDefaultTimeout</a> (uint32_t timeout)</td></tr>
<tr class="memdesc:a7e8a600fa59679e03debe2e6825a2bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a default <em>timeout</em>. <br /></td></tr>
<tr class="separator:a7e8a600fa59679e03debe2e6825a2bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fe2ba5aa3e4d0b89fa9cf7379444d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ac2fe2ba5aa3e4d0b89fa9cf7379444d3">setGotoConfigTimeout</a> (uint32_t timeout)=0</td></tr>
<tr class="memdesc:ac2fe2ba5aa3e4d0b89fa9cf7379444d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for the gotoConfig function.  <a href="struct_communicator.html#ac2fe2ba5aa3e4d0b89fa9cf7379444d3">More...</a><br /></td></tr>
<tr class="separator:ac2fe2ba5aa3e4d0b89fa9cf7379444d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0196bb20bc8db394d905dcbc00d14368"><td class="memItemLeft" align="right" valign="top"><a id="a0196bb20bc8db394d905dcbc00d14368"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a0196bb20bc8db394d905dcbc00d14368">setKeepAlive</a> (bool enable)=0</td></tr>
<tr class="memdesc:a0196bb20bc8db394d905dcbc00d14368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either disable or enable (default) the keep alive mechanism (if supported by the device) <br /></td></tr>
<tr class="separator:a0196bb20bc8db394d905dcbc00d14368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb314734f6189e93ff0efad49d76af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#adbb314734f6189e93ff0efad49d76af0">setMasterDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *<a class="el" href="struct_communicator.html#a4aa971b033b69bf5c79d800fee6e8723">masterDevice</a>)</td></tr>
<tr class="memdesc:adbb314734f6189e93ff0efad49d76af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a master device.  <a href="struct_communicator.html#adbb314734f6189e93ff0efad49d76af0">More...</a><br /></td></tr>
<tr class="separator:adbb314734f6189e93ff0efad49d76af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dfe2fd5d802d47bfd5281bd5da471a"><td class="memItemLeft" align="right" valign="top"><a id="aa9dfe2fd5d802d47bfd5281bd5da471a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aa9dfe2fd5d802d47bfd5281bd5da471a">waitForLastTaskCompletion</a> ()=0</td></tr>
<tr class="memdesc:aa9dfe2fd5d802d47bfd5281bd5da471a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the last processing task to complete in the threadpool. <br /></td></tr>
<tr class="separator:aa9dfe2fd5d802d47bfd5281bd5da471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba37c181a66e917085a31ab09205fc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ad4ba37c181a66e917085a31ab09205fc">writeMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)=0</td></tr>
<tr class="memdesc:ad4ba37c181a66e917085a31ab09205fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message to the device.  <a href="struct_communicator.html#ad4ba37c181a66e917085a31ab09205fc">More...</a><br /></td></tr>
<tr class="separator:ad4ba37c181a66e917085a31ab09205fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_callback_manager_xda"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_callback_manager_xda')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a></td></tr>
<tr class="memitem:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ae286810bd0b4d20678987b354fa13d29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ae286810bd0b4d20678987b354fa13d29">CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initializes the callback list. <br /></td></tr>
<tr class="separator:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5910d161433653494a59986643233cf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5910d161433653494a59986643233cf6">~CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, clears the callback list. <br /></td></tr>
<tr class="separator:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler to the list.  <a href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">More...</a><br /></td></tr>
<tr class="separator:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">addChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a chained manager to the list.  <a href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">More...</a><br /></td></tr>
<tr class="separator:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback list.  <a href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">More...</a><br /></td></tr>
<tr class="separator:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="acb7c60244a13f84ca7cc06efa50d9685"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acb7c60244a13f84ca7cc06efa50d9685">clearChainedManagers</a> ()</td></tr>
<tr class="memdesc:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the chained manager list. <br /></td></tr>
<tr class="separator:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">copyCallbackHandlersFrom</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from <em>cm</em> into this manager.  <a href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">More...</a><br /></td></tr>
<tr class="separator:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">copyCallbackHandlersTo</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from this manager into <em>cm</em>.  <a href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">More...</a><br /></td></tr>
<tr class="separator:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af2827956387a56712723e9200882179c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2827956387a56712723e9200882179c">onAllBufferedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5f103ff688afdeef381eedd6100331d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5f103ff688afdeef381eedd6100331d2">onAllDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5e64d70ce299958605b6149049e045ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5e64d70ce299958605b6149049e045ef">onAllLiveDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a4c0aa7e3be74595cef490b98d1520d1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a4c0aa7e3be74595cef490b98d1520d1e">onAllRecordedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6" title="Called when new data has been received for devices connected to the same main device in a recording s...">XsCallback::onAllRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ad4c8eb08edd64025b3e9405415b38834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad4c8eb08edd64025b3e9405415b38834">onBufferedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399" title="Called when XDA has a data packet that could be written to a log file.">XsCallback::onBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a312575546ab44f788dd3961477ba0e7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a312575546ab44f788dd3961477ba0e7f">onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState) override</td></tr>
<tr class="memdesc:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40" title="Called when XDA has detected a change in the connectivity state of a device.">XsCallback::onConnectivityChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="acc815adc25af17f24207573afa9c94da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acc815adc25af17f24207573afa9c94da">onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a7738059783802ad5e1278108a467ccc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7738059783802ad5e1278108a467ccc2">onDataUnavailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId) override</td></tr>
<tr class="memdesc:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga89d308afd509c0325b4cdb622fd9e645" title="Called when XDA detects that data is forever unavailable.">XsCallback::onDataUnavailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a1409c965b88efc664a2ef7d36e5490f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a1409c965b88efc664a2ef7d36e5490f4">onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState) override</td></tr>
<tr class="memdesc:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0" title="Called when a device&#39;s state has changed (ie config mode, measurement mode, recording mode)">XsCallback::onDeviceStateChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a3a65ae9866cb7a9e8ab11dcfeca1572f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a3a65ae9866cb7a9e8ab11dcfeca1572f">onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error) override</td></tr>
<tr class="memdesc:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onError() callback forwarding function. <br /></td></tr>
<tr class="separator:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a01afaba0ea9f47b5c4f490ee7dba7364"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364">onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request) override</td></tr>
<tr class="memdesc:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5" title="Called when an information request has resulted in a response.">XsCallback::onInfoResponse()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="aebd995bd1dc83e69822f874eabb0c4fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aebd995bd1dc83e69822f874eabb0c4fa">onLiveDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet) override</td></tr>
<tr class="memdesc:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af81b39fa94f8086d9682df2e53ea5e1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af81b39fa94f8086d9682df2e53ea5e1e">onMessageDetected</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage) override</td></tr>
<tr class="memdesc:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a760e93d7f7142fd22c7e134c4cea5f72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a760e93d7f7142fd22c7e134c4cea5f72">onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a73ec10bd8e7cf2df6b4136ad0ac9701e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a73ec10bd8e7cf2df6b4136ad0ac9701e">onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageSentToDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a79ae15c19c791af165c842441993660c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a79ae15c19c791af165c842441993660c">onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last) override</td></tr>
<tr class="memdesc:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e" title="Called when XDA detects that packets have been missed.">XsCallback::onMissedPackets()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="afdeff1e1697266d82f232642aef0cae9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#afdeff1e1697266d82f232642aef0cae9">onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onNonDataMessage() callback forwarding function. <br /></td></tr>
<tr class="separator:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a840ce749572d8997e33ee8f860db97c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a840ce749572d8997e33ee8f860db97c7">onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier) override</td></tr>
<tr class="memdesc:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59" title="Called when a long-duration operation has made some progress or has completed. Examples include loadL...">XsCallback::onProgressUpdated()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5b6beccc0e4760b652b7be01e859e465"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5b6beccc0e4760b652b7be01e859e465">onRecordedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14" title="Called when new data has been received from a device in a recording state or read from a file....">XsCallback::onRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af91bb23b63beb62d085182044abb30a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af91bb23b63beb62d085182044abb30a7">onRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result) override</td></tr>
<tr class="memdesc:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onRestoreCommunication callback forwarding function. <br /></td></tr>
<tr class="separator:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">onTransmissionRequest</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data) override</td></tr>
<tr class="memdesc:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">More...</a><br /></td></tr>
<tr class="separator:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a7471f499ee52bb189ef4e3917a20e5d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7471f499ee52bb189ef4e3917a20e5d0">onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev) override</td></tr>
<tr class="memdesc:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a" title="Called when a wakeup message has been received from a device. This indicates that the device has just...">XsCallback::onWakeupReceived()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ad510877b529df7a85fbc5d601c2fad76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad510877b529df7a85fbc5d601c2fad76">onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message) override</td></tr>
<tr class="memdesc:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290" title="Called when XDA has a message that could be written to a log file.">XsCallback::onWriteMessageToLogFile()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">More...</a><br /></td></tr>
<tr class="separator:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">removeChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove achained manager from the list.  <a href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">More...</a><br /></td></tr>
<tr class="separator:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_xs_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_xs_callback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_xs_callback.html">XsCallback</a></td></tr>
<tr class="memitem:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top"><a id="a491695016a32d02a31e2f4bda826ef47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a491695016a32d02a31e2f4bda826ef47">XsCallback</a> ()</td></tr>
<tr class="memdesc:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">~XsCallback</a> ()</td></tr>
<tr class="memdesc:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">More...</a><br /></td></tr>
<tr class="separator:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab6fad6bfc470a21b9165d3ed1825bc29"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab6fad6bfc470a21b9165d3ed1825bc29">configurationMessageSearchLimit</a> ()</td></tr>
<tr class="separator:ab6fad6bfc470a21b9165d3ed1825bc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf315317a87ae6b114b152c1685b9ea5"><td class="memTemplParams" colspan="2"><a id="adf315317a87ae6b114b152c1685b9ea5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf315317a87ae6b114b152c1685b9ea5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#adf315317a87ae6b114b152c1685b9ea5">createUniquePtr</a> ()</td></tr>
<tr class="memdesc:adf315317a87ae6b114b152c1685b9ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="struct_communicator.html" title="A base struct for a communication interface.">Communicator</a> of type T and returns it as a UniquePtr&lt;T&gt; <br /></td></tr>
<tr class="separator:adf315317a87ae6b114b152c1685b9ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a25ccfb89ac0b8c3d556b27ef33dcc"><td class="memTemplParams" colspan="2"><a id="ac6a25ccfb89ac0b8c3d556b27ef33dcc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6a25ccfb89ac0b8c3d556b27ef33dcc"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ac6a25ccfb89ac0b8c3d556b27ef33dcc">createUniquePtr</a> (T *communicator)</td></tr>
<tr class="memdesc:ac6a25ccfb89ac0b8c3d556b27ef33dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a UniquePtr&lt;T&gt; from a Communicator*. <br /></td></tr>
<tr class="separator:ac6a25ccfb89ac0b8c3d556b27ef33dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4ced5362bf7438924f8d7f1b0c5ec391"><td class="memItemLeft" align="right" valign="top"><a id="a4ced5362bf7438924f8d7f1b0c5ec391"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4ced5362bf7438924f8d7f1b0c5ec391">~Communicator</a> ()</td></tr>
<tr class="memdesc:a4ced5362bf7438924f8d7f1b0c5ec391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, waits for the last scheduled task to complete and then cleans up the object by calling clear() <br /></td></tr>
<tr class="separator:a4ced5362bf7438924f8d7f1b0c5ec391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa971b033b69bf5c79d800fee6e8723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4aa971b033b69bf5c79d800fee6e8723">masterDevice</a> () const</td></tr>
<tr class="separator:a4aa971b033b69bf5c79d800fee6e8723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026c067510b8e1652a1495787f74072"><td class="memItemLeft" align="right" valign="top"><a id="ae026c067510b8e1652a1495787f74072"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ae026c067510b8e1652a1495787f74072">prepareForDestruction</a> ()</td></tr>
<tr class="memdesc:ae026c067510b8e1652a1495787f74072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares communicator for destruction. <br /></td></tr>
<tr class="separator:ae026c067510b8e1652a1495787f74072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72c82f6987d62565f8107e1ba93cfa6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_protocol_manager.html">ProtocolManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ae72c82f6987d62565f8107e1ba93cfa6">protocolManager</a> () const</td></tr>
<tr class="separator:ae72c82f6987d62565f8107e1ba93cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec58651d63e9b69d54b2a77eff784d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ad3ec58651d63e9b69d54b2a77eff784d">setAndReturnLastResult</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">lastResult</a>, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;text=<a class="el" href="struct_xs_string.html">XsString</a>()) const</td></tr>
<tr class="memdesc:ad3ec58651d63e9b69d54b2a77eff784d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last result and returns it.  <a href="struct_communicator.html#ad3ec58651d63e9b69d54b2a77eff784d">More...</a><br /></td></tr>
<tr class="separator:ad3ec58651d63e9b69d54b2a77eff784d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37b0ef25e91141a622aff2be6c2cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a2f37b0ef25e91141a622aff2be6c2cd7">setLastResult</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">lastResult</a>, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;text=<a class="el" href="struct_xs_string.html">XsString</a>()) const</td></tr>
<tr class="memdesc:a2f37b0ef25e91141a622aff2be6c2cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last result.  <a href="struct_communicator.html#a2f37b0ef25e91141a622aff2be6c2cd7">More...</a><br /></td></tr>
<tr class="separator:a2f37b0ef25e91141a622aff2be6c2cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba6a5ee540ee88b2a7c8d7a92ab4bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aeba6a5ee540ee88b2a7c8d7a92ab4bad">setMasterDeviceId</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId)</td></tr>
<tr class="memdesc:aeba6a5ee540ee88b2a7c8d7a92ab4bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a master device ID.  <a href="struct_communicator.html#aeba6a5ee540ee88b2a7c8d7a92ab4bad">More...</a><br /></td></tr>
<tr class="separator:aeba6a5ee540ee88b2a7c8d7a92ab4bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae97ac949b7898d0d52cd1e7e4db8f7a6"><td class="memItemLeft" align="right" valign="top"><a id="ae97ac949b7898d0d52cd1e7e4db8f7a6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ae97ac949b7898d0d52cd1e7e4db8f7a6">m_defaultTimeout</a></td></tr>
<tr class="memdesc:ae97ac949b7898d0d52cd1e7e4db8f7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default timeout variable. <br /></td></tr>
<tr class="separator:ae97ac949b7898d0d52cd1e7e4db8f7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90164a6964ce680a2bb6c750e3121437"><td class="memItemLeft" align="right" valign="top"><a id="a90164a6964ce680a2bb6c750e3121437"></a>
<a class="el" href="classxsens_1_1_mutex.html">xsens::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a90164a6964ce680a2bb6c750e3121437">m_handleMux</a></td></tr>
<tr class="memdesc:a90164a6964ce680a2bb6c750e3121437"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle mutex. <br /></td></tr>
<tr class="separator:a90164a6964ce680a2bb6c750e3121437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852b00fd08541b3fc1a7ff12684b75f9"><td class="memItemLeft" align="right" valign="top"><a id="a852b00fd08541b3fc1a7ff12684b75f9"></a>
<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a852b00fd08541b3fc1a7ff12684b75f9">m_lastResult</a></td></tr>
<tr class="memdesc:a852b00fd08541b3fc1a7ff12684b75f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A last result variable. <br /></td></tr>
<tr class="separator:a852b00fd08541b3fc1a7ff12684b75f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65c6bae276812a005291e60b9d2c47b"><td class="memItemLeft" align="right" valign="top"><a id="ab65c6bae276812a005291e60b9d2c47b"></a>
<a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab65c6bae276812a005291e60b9d2c47b">m_lastResultText</a></td></tr>
<tr class="memdesc:ab65c6bae276812a005291e60b9d2c47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A last result string. <br /></td></tr>
<tr class="separator:ab65c6bae276812a005291e60b9d2c47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0afe5fa12dec79e590dc1dbcde56281"><td class="memItemLeft" align="right" valign="top"><a id="ab0afe5fa12dec79e590dc1dbcde56281"></a>
<a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab0afe5fa12dec79e590dc1dbcde56281">m_masterDeviceId</a></td></tr>
<tr class="memdesc:ab0afe5fa12dec79e590dc1dbcde56281"><td class="mdescLeft">&#160;</td><td class="mdescRight">A master device ID. <br /></td></tr>
<tr class="separator:ab0afe5fa12dec79e590dc1dbcde56281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e99c203184a28f906cda4bea0498e8b"><td class="memItemLeft" align="right" valign="top"><a id="a4e99c203184a28f906cda4bea0498e8b"></a>
<a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4e99c203184a28f906cda4bea0498e8b">m_masterInfo</a></td></tr>
<tr class="memdesc:a4e99c203184a28f906cda4bea0498e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A master device object. <br /></td></tr>
<tr class="separator:a4e99c203184a28f906cda4bea0498e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ec352c0ac50f5c333baff1943e87d7"><td class="memItemLeft" align="right" valign="top"><a id="aa0ec352c0ac50f5c333baff1943e87d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aa0ec352c0ac50f5c333baff1943e87d7">m_preparedForDestruction</a></td></tr>
<tr class="memdesc:aa0ec352c0ac50f5c333baff1943e87d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepared for destruction boolean variable. <br /></td></tr>
<tr class="separator:aa0ec352c0ac50f5c333baff1943e87d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4720fef928a6aaab1dc7ec743f53a173"><td class="memItemLeft" align="right" valign="top"><a id="a4720fef928a6aaab1dc7ec743f53a173"></a>
std::shared_ptr&lt; <a class="el" href="class_protocol_manager.html">ProtocolManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4720fef928a6aaab1dc7ec743f53a173">m_protocolManager</a></td></tr>
<tr class="memdesc:a4720fef928a6aaab1dc7ec743f53a173"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shared pointer to protocl manager. <br /></td></tr>
<tr class="separator:a4720fef928a6aaab1dc7ec743f53a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6345ad9fb045e3d1de7c2370deaeef63"><td class="memItemLeft" align="right" valign="top"><a id="a6345ad9fb045e3d1de7c2370deaeef63"></a>
std::unique_ptr&lt; <a class="el" href="classxsens_1_1_reply_monitor.html">xsens::ReplyMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a6345ad9fb045e3d1de7c2370deaeef63">m_replyMonitor</a></td></tr>
<tr class="memdesc:a6345ad9fb045e3d1de7c2370deaeef63"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unique pointer to a reply monitor. <br /></td></tr>
<tr class="separator:a6345ad9fb045e3d1de7c2370deaeef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_struct_xs_callback_plain_c"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_struct_xs_callback_plain_c')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a></td></tr>
<tr class="memitem:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">m_onAllBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">More...</a><br /></td></tr>
<tr class="separator:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">m_onAllDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">More...</a><br /></td></tr>
<tr class="separator:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">m_onAllLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">More...</a><br /></td></tr>
<tr class="separator:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">m_onAllRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">More...</a><br /></td></tr>
<tr class="separator:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">m_onBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">More...</a><br /></td></tr>
<tr class="separator:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">More...</a><br /></td></tr>
<tr class="separator:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">More...</a><br /></td></tr>
<tr class="separator:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">m_onDataUnavailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable.  <a href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">More...</a><br /></td></tr>
<tr class="separator:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">More...</a><br /></td></tr>
<tr class="separator:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">More...</a><br /></td></tr>
<tr class="separator:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">More...</a><br /></td></tr>
<tr class="separator:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">m_onLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">More...</a><br /></td></tr>
<tr class="separator:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">m_onMessageDetected</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">More...</a><br /></td></tr>
<tr class="separator:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">More...</a><br /></td></tr>
<tr class="separator:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">More...</a><br /></td></tr>
<tr class="separator:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">More...</a><br /></td></tr>
<tr class="separator:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">More...</a><br /></td></tr>
<tr class="separator:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">More...</a><br /></td></tr>
<tr class="separator:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">m_onRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">More...</a><br /></td></tr>
<tr class="separator:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">m_onRestoreCommunication</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occurred.  <a href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">More...</a><br /></td></tr>
<tr class="separator:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">m_onTransmissionRequest</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">More...</a><br /></td></tr>
<tr class="separator:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">More...</a><br /></td></tr>
<tr class="separator:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">More...</a><br /></td></tr>
<tr class="separator:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A base struct for a communication interface. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab9133a96d8f5d3f602981bcf1d8b74ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9133a96d8f5d3f602981bcf1d8b74ac">&#9670;&nbsp;</a></span>addProtocolHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Communicator::addProtocolHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_protocol_handler.html">IProtocolHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a protocol handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>an <a class="el" href="class_i_protocol_handler.html">IProtocolHandler</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_mtb_file_communicator.html#a004d7d02ad4007707f78064a658dc930">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a5f7cb30f37dd08db96c76ab3c86e014b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7cb30f37dd08db96c76ab3c86e014b">&#9670;&nbsp;</a></span>addReplyObject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt; Communicator::addReplyObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_reply_object.html">ReplyObject</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a custom <a class="el" href="class_reply_object.html" title="Abstract reply object. Blocks on a semaphore when requesting the message until the message has been s...">ReplyObject</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The reply object to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the supplied reply object </dd></dl>

</div>
</div>
<a id="aba83d20bf72bcfc7df91564159d2a947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba83d20bf72bcfc7df91564159d2a947">&#9670;&nbsp;</a></span>addReplyObject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt; Communicator::addReplyObject </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="class_mid_reply_object.html" title="Reply object that only checks the message identifier.">MidReplyObject</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mid</td><td>the id of the message to wait for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to a reply object </dd></dl>

</div>
</div>
<a id="a331d3bc7f8845fd6d8b62a64dde8f9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331d3bc7f8845fd6d8b62a64dde8f9a5">&#9670;&nbsp;</a></span>addReplyObject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt; Communicator::addReplyObject </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="class_mid_and_data_reply_object.html" title="Reply object that checks the message identifier and data in the data field.">MidAndDataReplyObject</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mid</td><td>the message id of the message to wait for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>the offset in the data part of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size of the data in the data part of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to data to wait for (this object does not take ownership of the data) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to a reply object </dd></dl>

</div>
</div>
<a id="a44e4963e852857d8e919978b5384ea3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e4963e852857d8e919978b5384ea3b">&#9670;&nbsp;</a></span>allowReprocessing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Communicator::allowReprocessing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if reprocessing is allowed </dd></dl>

<p>Reimplemented in <a class="el" href="class_proxy_communicator.html#a1ff4588a166118ab93b413cdb49dd7d5">ProxyCommunicator</a>.</p>

</div>
</div>
<a id="af4c99be8ee160af0e79888622b9bd44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c99be8ee160af0e79888622b9bd44b">&#9670;&nbsp;</a></span>childDeviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsSize Communicator::childDeviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a child device count </dd></dl>

</div>
</div>
<a id="a40bb7b535e5fbcb2657a1aa09d0ccd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bb7b535e5fbcb2657a1aa09d0ccd9e">&#9670;&nbsp;</a></span>closeLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Communicator::closeLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the log file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the log file was successfully closed or never open </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#a27bcb5ce4cfb9c82b2d5ccb03e4cbf25">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a78208205ae08de9eb3c5c6af6ec98ae9">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="ab6fad6bfc470a21b9165d3ed1825bc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fad6bfc470a21b9165d3ed1825bc29">&#9670;&nbsp;</a></span>configurationMessageSearchLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Communicator::configurationMessageSearchLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum set of messages, from the beginning of a file, which must contain a Configuration message </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_serial_communicator.html" title="A class that uses serial communication.">SerialCommunicator</a> &amp; MTi: 5 (GotoConfig, ReqDeviceId, GotoConfig, Initbus, ReqConfiguration) </dd>
<dd>
BodyPack requires more because we also may have some other meta-data in the file, but base is: 7 (ReqDeviceId, RequestControl, SetDataPort, GotoConfig [<a class="el" href="struct_communicator.html" title="A base struct for a communication interface.">Communicator</a> &amp; <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>], Initbus, ReqConfiguration) </dd></dl>

</div>
</div>
<a id="a20c7d171bbc01a004f50b414621cb7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c7d171bbc01a004f50b414621cb7e8">&#9670;&nbsp;</a></span>defaultTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Communicator::defaultTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a default timeout </dd></dl>

</div>
</div>
<a id="ad8bae91c2bbbfd74e56ff0ee1bdb27d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bae91c2bbbfd74e56ff0ee1bdb27d5">&#9670;&nbsp;</a></span>getDeviceId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> Communicator::getDeviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to get device ID. </p>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#aadfac8c5baf5899efdf13d3ab571d30f">MtbFileCommunicator</a>, and <a class="el" href="class_device_communicator.html#a35068f4c2ecb7ba1a1b678f86e461509">DeviceCommunicator</a>.</p>

</div>
</div>
<a id="a7e183d2fdad136d39d96bb69da118dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e183d2fdad136d39d96bb69da118dc4">&#9670;&nbsp;</a></span>gotoConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> Communicator::gotoConfig </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to go to config mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detectRs485</td><td>when set to true it will try to detect and use an RS485 interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#aa8e2c3b899ae1a06b703e30d5a5f0671">DeviceCommunicator</a>, <a class="el" href="class_mtb_file_communicator.html#a49ce6dc7dfa92438f88c1bee18197f12">MtbFileCommunicator</a>, <a class="el" href="class_serial_communicator.html#adf52f0663501d1bb619daa0f4193900d">SerialCommunicator</a>, and <a class="el" href="class_usb_communicator.html#a80519e7b42fab5ddd3235db7b531abfa">UsbCommunicator</a>.</p>

</div>
</div>
<a id="a29fecb5f975db28879d7e8cdb600ddc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fecb5f975db28879d7e8cdb600ddc3">&#9670;&nbsp;</a></span>gotoMeasurement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> Communicator::gotoMeasurement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to go to measurement mode. </p>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#a345f59969ccaa52892a8484bb987267e">MtbFileCommunicator</a>, <a class="el" href="class_device_communicator.html#a33cffe54111a55082cb548a05f4dd625">DeviceCommunicator</a>, <a class="el" href="class_serial_communicator.html#a4460b389c9fefcdab6cb083dfb6edc1b">SerialCommunicator</a>, and <a class="el" href="class_usb_communicator.html#a3a53aef49e099a374a3d8ee31934db4b">UsbCommunicator</a>.</p>

</div>
</div>
<a id="a89f838f1f5da8b3ec5cba61a47d6ee2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f838f1f5da8b3ec5cba61a47d6ee2a">&#9670;&nbsp;</a></span>hasProtocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Communicator::hasProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when a protocol with type <em>type</em> has been added </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The protocol type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeecf3bf1cbd0f42de59123450833d680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecf3bf1cbd0f42de59123450833d680">&#9670;&nbsp;</a></span>isLoadLogFileInProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Communicator::isLoadLogFileInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the file operation started by loadLogFile is still in progress </dd></dl>

<p>Reimplemented in <a class="el" href="class_mtb_file_communicator.html#ad1d3ca888b5603ab469bc1f1ac79de6e">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a5e3961efd576ab1736b51b6675a28fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3961efd576ab1736b51b6675a28fb3">&#9670;&nbsp;</a></span>isPortOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Communicator::isPortOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the port is open </dd></dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#a87ab4a685db5ae979f0c5d8a711ab06b">MtbFileCommunicator</a>, <a class="el" href="class_serial_communicator.html#a4d9b768ea4848dd86b1a3bb031a9a279">SerialCommunicator</a>, and <a class="el" href="class_proxy_communicator.html#a08a2e59aad4a9e141d9caeeae1e6f6ee">ProxyCommunicator</a>.</p>

</div>
</div>
<a id="a68b11375cf627734ba69e619691fba31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b11375cf627734ba69e619691fba31">&#9670;&nbsp;</a></span>isReadingFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Communicator::isReadingFromFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if we are reading from the file </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#ac9196da91fe442024b4dc2465efb57b3">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a8b00cea4663b9472e39499cc9e3b2602">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a01b1f15cfc16c51f839f0fc5f57060a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b1f15cfc16c51f839f0fc5f57060a6">&#9670;&nbsp;</a></span>lastResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> Communicator::lastResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result value of the last operation. </p>
<p>The result values are codes that describe a failure in more detail. </p><dl class="section return"><dt>Returns</dt><dd>the last known error code </dd></dl>
<dl class="section see"><dt>See also</dt><dd>resultText(XsResultValue), <a class="el" href="struct_communicator.html#ace27546fc55e56bc861e1c29bf7955a7" title="Get the accompanying error text for the value returned by lastResult() It may provide situation-speci...">lastResultText()</a> </dd></dl>

</div>
</div>
<a id="ace27546fc55e56bc861e1c29bf7955a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace27546fc55e56bc861e1c29bf7955a7">&#9670;&nbsp;</a></span>lastResultText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> Communicator::lastResultText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the accompanying error text for the value returned by <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6" title="Get the result value of the last operation.">lastResult()</a> It may provide situation-specific information instead. </p>
<dl class="section return"><dt>Returns</dt><dd>a human readable error description </dd></dl>
<dl class="section see"><dt>See also</dt><dd>resultText(XsResultValue), <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>

</div>
</div>
<a id="a388a1ae810ecad38c93ca03de5be1c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388a1ae810ecad38c93ca03de5be1c9d">&#9670;&nbsp;</a></span>logFileDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> Communicator::logFileDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The date of the logfile </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#a51fe0fc2981d484358004c21de3b0c9f">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a9805bfdb282c86fac2b0303a4a36bbd7">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a2b6288d0041d1116a063f1d92f4ce4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6288d0041d1116a063f1d92f4ce4a9">&#9670;&nbsp;</a></span>logFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_xs_string.html">XsString</a> Communicator::logFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name of the logfile </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#a52210286f5b661d724e5233d6febaf11">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#aa36d59ed9a6ad743520cd2707ebeb878">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a1d2a49e9a8ff16018c5b8d5631c63e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2a49e9a8ff16018c5b8d5631c63e97">&#9670;&nbsp;</a></span>logFileReadPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> Communicator::logFileReadPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The read position of the logfile </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#a612ff63b5ceac3ebad1d48ee29eba4e5">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#aaebdd9ca5ea57f90521be8b1dc1965c7">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a2215784fb1364868b89ce60518c0c1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2215784fb1364868b89ce60518c0c1e3">&#9670;&nbsp;</a></span>logFileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> Communicator::logFileSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the logfile </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#ac2cd1dca9b2bf6ad5221b6a720687fd3">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a425a367a771a94d1e47dcb791bc3b9d2">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a4aa971b033b69bf5c79d800fee6e8723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa971b033b69bf5c79d800fee6e8723">&#9670;&nbsp;</a></span>masterDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * Communicator::masterDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a master device </dd></dl>

</div>
</div>
<a id="a849c63e78f350c54778c4fd31924ac92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849c63e78f350c54778c4fd31924ac92">&#9670;&nbsp;</a></span>masterDeviceId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> Communicator::masterDeviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a master device ID </dd></dl>

</div>
</div>
<a id="ab869c9bf1289e05b4289060cb3d113b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab869c9bf1289e05b4289060cb3d113b2">&#9670;&nbsp;</a></span>openLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Communicator::openLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the log file `. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>a name of file to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was opened successfully </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#a631e19150338942aee3f7b623cfadc5b">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a98c932f470af852f095a7ff41f774234">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="aa111ea807518c31210865dc0343a3b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa111ea807518c31210865dc0343a3b22">&#9670;&nbsp;</a></span>openPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Communicator::openPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a>&#160;</td>
          <td class="paramname"><em>stage</em> = <code>OPS_Full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portInfo</td><td>A port information that you want to open </td></tr>
    <tr><td class="paramname">stage</td><td>A openning stage of a communication port </td></tr>
    <tr><td class="paramname">detectRs485</td><td>When set to true it will try to detect and use an RS485 interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is successfully open </dd></dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#ae49568e601aed36f9b2f1ec4da338f46">MtbFileCommunicator</a>, <a class="el" href="class_serial_communicator.html#a27780c1383cf7e88067e92ad88abd941">SerialCommunicator</a>, and <a class="el" href="class_proxy_communicator.html#a7721401974d3b9d1a09e489d5dedb367">ProxyCommunicator</a>.</p>

</div>
</div>
<a id="a1a4ba050c31e70abd4565dd505d6387c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4ba050c31e70abd4565dd505d6387c">&#9670;&nbsp;</a></span>portInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> Communicator::portInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_xs_port_info.html" title="Contains a descriptor for opening a communication port to an Xsens device.">XsPortInfo</a> of the current port </dd></dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#a90baa66d3f9098833531da0b8be26b4a">MtbFileCommunicator</a>, and <a class="el" href="class_serial_communicator.html#a14b088f177fa2d4628fd8db0ac59db4e">SerialCommunicator</a>.</p>

</div>
</div>
<a id="ae72c82f6987d62565f8107e1ba93cfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72c82f6987d62565f8107e1ba93cfa6">&#9670;&nbsp;</a></span>protocolManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_protocol_manager.html">ProtocolManager</a> &gt; Communicator::protocolManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a protocol manager </dd></dl>

</div>
</div>
<a id="a692484e8c4f7a588f49a3cb1123a962f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692484e8c4f7a588f49a3cb1123a962f">&#9670;&nbsp;</a></span>readMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_xs_message.html">XsMessage</a> Communicator::readMessage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a message from the open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>an ID of message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The message that was read or if no matching message was found a cleared message </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#ac723389cb3a92390ad2231ac28d26418">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a312ba4a98023822449dae795d7ae4a72">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="af2651a48958605e80d6e3e4519f438d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2651a48958605e80d6e3e4519f438d6">&#9670;&nbsp;</a></span>readMessageFromStartOfFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_xs_message.html">XsMessage</a> Communicator::readMessageFromStartOfFile </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxMsgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a message from the start of the open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>an ID of message </td></tr>
    <tr><td class="paramname">maxMsgs</td><td>a maximum of messages to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The message that was read or if no matching message was found a cleared message </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#a77a75986ca407bb3f32745a3a17072fe">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a3c86e20a386e73ddce139bb7e312e9fa">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="aeba8fe953887ceea6a42ae27f80d58d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba8fe953887ceea6a42ae27f80d58d7">&#9670;&nbsp;</a></span>readMessagesFromStartOfFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::deque&lt;<a class="el" href="struct_xs_message.html">XsMessage</a>&gt; Communicator::readMessagesFromStartOfFile </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxMsgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read multiple similar messages from the start of the open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>an ID of message </td></tr>
    <tr><td class="paramname">maxMsgs</td><td>a maximum of messages to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The message that was read or if no matching message was found a cleared message </dd></dl>

<p>Implemented in <a class="el" href="class_device_communicator.html#a4bbdc9a4169b0addfdc0e986d95843c8">DeviceCommunicator</a>, and <a class="el" href="class_mtb_file_communicator.html#a9b8207e51e5e32f36da3c50688b75bf5">MtbFileCommunicator</a>.</p>

</div>
</div>
<a id="a7ef923814a0a92a47cd747f688fd5aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef923814a0a92a47cd747f688fd5aac">&#9670;&nbsp;</a></span>removeProtocolHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Communicator::removeProtocolHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a protocol handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>a <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa96111aa187a632a62242b5d3dd08787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96111aa187a632a62242b5d3dd08787">&#9670;&nbsp;</a></span>reopenPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Communicator::reopenPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a>&#160;</td>
          <td class="paramname"><em>stage</em> = <code>OPS_Full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipDeviceIdCheck</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reopens the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>A openning stage of a communication port </td></tr>
    <tr><td class="paramname">skipDeviceIdCheck</td><td>When set to true it will skip device ID check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is successfully reopened </dd></dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#a515b5fc108dd7f5e6ff82ec8ccae08ec">MtbFileCommunicator</a>, <a class="el" href="class_serial_communicator.html#aa2a8c4805b940d5bf68d722b4d4aba3d">SerialCommunicator</a>, and <a class="el" href="class_proxy_communicator.html#aa9a292f3e54ed61f73689d80d152afd1">ProxyCommunicator</a>.</p>

</div>
</div>
<a id="ab0efda63671e15cc3f4b8862d8827610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0efda63671e15cc3f4b8862d8827610">&#9670;&nbsp;</a></span>sanityCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Communicator::sanityCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a sanity check on a potential message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>a message</td></tr>
  </table>
  </dd>
</dl>
<p>This check is done to prevent message loss due to a 'valid' message in a message Check if the busId can be valid. It can be XS_BID_MASTER and is must be below the number of devices The XS_BID_BROADCAST cannot be checked due to a bug in AwindaStation firmware 1.0.9 which sends flushing indications with BID 0 Later more checks like odd message ID checks may be added here </p><dl class="section return"><dt>Returns</dt><dd>true if check is successful </dd></dl>

</div>
</div>
<a id="ad3ec58651d63e9b69d54b2a77eff784d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ec58651d63e9b69d54b2a77eff784d">&#9670;&nbsp;</a></span>setAndReturnLastResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> Communicator::setAndReturnLastResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code><a class="el" href="struct_xs_string.html">XsString</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the last result and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>a result value </td></tr>
    <tr><td class="paramname">text</td><td>a text string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if successful </dd></dl>

</div>
</div>
<a id="a96aebec75db10bb2ddf1e8d677b3adcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aebec75db10bb2ddf1e8d677b3adcd">&#9670;&nbsp;</a></span>setCredentials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Communicator::setCredentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the credentials required for using the device. </p>
<p>Mostly used for network access </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The username or system ID or similar </td></tr>
    <tr><td class="paramname">key</td><td>The authentication key or password or similar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2fe2ba5aa3e4d0b89fa9cf7379444d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fe2ba5aa3e4d0b89fa9cf7379444d3">&#9670;&nbsp;</a></span>setGotoConfigTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Communicator::setGotoConfigTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the timeout for the gotoConfig function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The desired timeout value in ms, if 0 the default value is used </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#ace1645929c7d07b082781a3d242be48f">MtbFileCommunicator</a>, and <a class="el" href="class_device_communicator.html#a938d7f7eeec56a8c3c1a85b56cad40c9">DeviceCommunicator</a>.</p>

</div>
</div>
<a id="a2f37b0ef25e91141a622aff2be6c2cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f37b0ef25e91141a622aff2be6c2cd7">&#9670;&nbsp;</a></span>setLastResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Communicator::setLastResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code><a class="el" href="struct_xs_string.html">XsString</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the last result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>a result value </td></tr>
    <tr><td class="paramname">text</td><td>a text string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbb314734f6189e93ff0efad49d76af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb314734f6189e93ff0efad49d76af0">&#9670;&nbsp;</a></span>setMasterDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Communicator::setMasterDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>masterDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a master device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">masterDevice</td><td>a master device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeba6a5ee540ee88b2a7c8d7a92ab4bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba6a5ee540ee88b2a7c8d7a92ab4bad">&#9670;&nbsp;</a></span>setMasterDeviceId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Communicator::setMasterDeviceId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a master device ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ba37c181a66e917085a31ab09205fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ba37c181a66e917085a31ab09205fc">&#9670;&nbsp;</a></span>writeMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Communicator::writeMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write message to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>a message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful write, false otherwise. This doesn't guarantee proper delivery of the message. Use doTransaction for that </dd></dl>

<p>Implemented in <a class="el" href="class_mtb_file_communicator.html#a449e545f43bff28ba7971288f1f4f924">MtbFileCommunicator</a>, and <a class="el" href="class_device_communicator.html#a69e56cfd099e36515116a89b77122d71">DeviceCommunicator</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_communicator.html">Communicator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
