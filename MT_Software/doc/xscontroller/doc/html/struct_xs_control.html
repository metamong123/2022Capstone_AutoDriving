<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XsController: XsControl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xsenslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XsController
   &#160;<span id="projectnumber">2021.4.0</span>
   </div>
   <div id="projectbrief">Xsens Device API Public Communication Objects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_xs_control.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="struct_xs_control-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsControl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>High level Motion Tracker (MT) management class.  
 <a href="struct_xs_control.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for XsControl:</div>
<div class="dyncontent">
<div class="center"><img src="struct_xs_control__inherit__graph.png" border="0" usemap="#_xs_control_inherit__map" alt="Inheritance graph"/></div>
<map name="_xs_control_inherit__map" id="_xs_control_inherit__map">
<area shape="rect" title="High level Motion Tracker (MT) management class." alt="" coords="42,229,127,256"/>
<area shape="rect" href="struct_xs_control_ex.html" title="An abstract internal struct of a control object." alt="" coords="34,304,135,331"/>
<area shape="rect" href="class_callback_manager_xda.html" title="Class that delegates callbacks to registered XsCallbackHandlerItems." alt="" coords="5,155,164,181"/>
<area shape="rect" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API." alt="" coords="37,80,132,107"/>
<area shape="rect" href="struct_xs_callback_plain_c.html" title="Structure that contains callback functions for the Xsens Device API." alt="" coords="17,5,152,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4581ed8c305367d1d4df972b8d8ff1c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4581ed8c305367d1d4df972b8d8ff1c8">XsControl</a> ()</td></tr>
<tr class="memdesc:a4581ed8c305367d1d4df972b8d8ff1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Xsens Device API control object.  <a href="struct_xs_control.html#a4581ed8c305367d1d4df972b8d8ff1c8">More...</a><br /></td></tr>
<tr class="separator:a4581ed8c305367d1d4df972b8d8ff1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370ec5f19b1c42b23d9d7abd453787c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a370ec5f19b1c42b23d9d7abd453787c4">~XsControl</a> ()</td></tr>
<tr class="memdesc:a370ec5f19b1c42b23d9d7abd453787c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object.  <a href="struct_xs_control.html#a370ec5f19b1c42b23d9d7abd453787c4">More...</a><br /></td></tr>
<tr class="separator:a370ec5f19b1c42b23d9d7abd453787c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189065247d7fb3758a355c403c68866d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a189065247d7fb3758a355c403c68866d">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a189065247d7fb3758a355c403c68866d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.  <a href="struct_xs_control.html#a189065247d7fb3758a355c403c68866d">More...</a><br /></td></tr>
<tr class="separator:a189065247d7fb3758a355c403c68866d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1f958d74b3969deb4f82cb888648f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0b1f958d74b3969deb4f82cb888648f1">broadcast</a> () const</td></tr>
<tr class="memdesc:a0b1f958d74b3969deb4f82cb888648f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the broadcast device.  <a href="struct_xs_control.html#a0b1f958d74b3969deb4f82cb888648f1">More...</a><br /></td></tr>
<tr class="separator:a0b1f958d74b3969deb4f82cb888648f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f24c9ba286897b176f4fb8efd0f285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a30f24c9ba286897b176f4fb8efd0f285">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:a30f24c9ba286897b176f4fb8efd0f285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.  <a href="struct_xs_control.html#a30f24c9ba286897b176f4fb8efd0f285">More...</a><br /></td></tr>
<tr class="separator:a30f24c9ba286897b176f4fb8efd0f285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a38dfa34e345ac68d4ebf2734658df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a09a38dfa34e345ac68d4ebf2734658df">clearHardwareError</a> ()</td></tr>
<tr class="memdesc:a09a38dfa34e345ac68d4ebf2734658df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the last hardware error.  <a href="struct_xs_control.html#a09a38dfa34e345ac68d4ebf2734658df">More...</a><br /></td></tr>
<tr class="separator:a09a38dfa34e345ac68d4ebf2734658df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b22e73c092c0206e766d8e37ff0836f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a5b22e73c092c0206e766d8e37ff0836f">close</a> ()</td></tr>
<tr class="memdesc:a5b22e73c092c0206e766d8e37ff0836f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all ports and files.  <a href="struct_xs_control.html#a5b22e73c092c0206e766d8e37ff0836f">More...</a><br /></td></tr>
<tr class="separator:a5b22e73c092c0206e766d8e37ff0836f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfd08f3e7c65b057062bcbed1f425b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a90cfd08f3e7c65b057062bcbed1f425b">closeCustomPort</a> (int channelId)</td></tr>
<tr class="memdesc:a90cfd08f3e7c65b057062bcbed1f425b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a custom communication channel.  <a href="struct_xs_control.html#a90cfd08f3e7c65b057062bcbed1f425b">More...</a><br /></td></tr>
<tr class="separator:a90cfd08f3e7c65b057062bcbed1f425b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2a3ac5d55588c89de12347b17304a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aee2a3ac5d55588c89de12347b17304a2">closePort</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId)</td></tr>
<tr class="memdesc:aee2a3ac5d55588c89de12347b17304a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the port that is used for communication with the given <em>deviceId</em>.  <a href="struct_xs_control.html#aee2a3ac5d55588c89de12347b17304a2">More...</a><br /></td></tr>
<tr class="separator:aee2a3ac5d55588c89de12347b17304a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ce0525bfbd2726822d8d04306f8ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a16ce0525bfbd2726822d8d04306f8ba3">closePort</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo)</td></tr>
<tr class="memdesc:a16ce0525bfbd2726822d8d04306f8ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port that matches <em>portinfo</em>.  <a href="struct_xs_control.html#a16ce0525bfbd2726822d8d04306f8ba3">More...</a><br /></td></tr>
<tr class="separator:a16ce0525bfbd2726822d8d04306f8ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79">closePort</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portname)</td></tr>
<tr class="memdesc:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port with the given <em>portname</em>.  <a href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79">More...</a><br /></td></tr>
<tr class="separator:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47afe51569172239121d6f0520b93d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a47afe51569172239121d6f0520b93d6e">closePort</a> (int portNr)</td></tr>
<tr class="memdesc:a47afe51569172239121d6f0520b93d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port with the given <em>portNr</em>.  <a href="struct_xs_control.html#a47afe51569172239121d6f0520b93d6e">More...</a><br /></td></tr>
<tr class="separator:a47afe51569172239121d6f0520b93d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0525d061264b6622fc2aa68aff592746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0525d061264b6622fc2aa68aff592746">closePort</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *<a class="el" href="struct_xs_control.html#a908f5a025aef35e11a4e4583eb0c55a8">device</a>)</td></tr>
<tr class="memdesc:a0525d061264b6622fc2aa68aff592746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the device port with the given <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>.  <a href="struct_xs_control.html#a0525d061264b6622fc2aa68aff592746">More...</a><br /></td></tr>
<tr class="separator:a0525d061264b6622fc2aa68aff592746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53abcb328a487f53f2901ddfcd366031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a53abcb328a487f53f2901ddfcd366031">customPortInfo</a> (int channelId) const</td></tr>
<tr class="memdesc:a53abcb328a487f53f2901ddfcd366031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port information for a custom communication channel.  <a href="struct_xs_control.html#a53abcb328a487f53f2901ddfcd366031">More...</a><br /></td></tr>
<tr class="separator:a53abcb328a487f53f2901ddfcd366031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908f5a025aef35e11a4e4583eb0c55a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a908f5a025aef35e11a4e4583eb0c55a8">device</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const</td></tr>
<tr class="memdesc:a908f5a025aef35e11a4e4583eb0c55a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface object associated with the supplied <em>deviceId</em>.  <a href="struct_xs_control.html#a908f5a025aef35e11a4e4583eb0c55a8">More...</a><br /></td></tr>
<tr class="separator:a908f5a025aef35e11a4e4583eb0c55a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93286830447b6f512e189adb328c51b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a93286830447b6f512e189adb328c51b7">deviceCount</a> () const</td></tr>
<tr class="memdesc:a93286830447b6f512e189adb328c51b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected devices.  <a href="struct_xs_control.html#a93286830447b6f512e189adb328c51b7">More...</a><br /></td></tr>
<tr class="separator:a93286830447b6f512e189adb328c51b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b05d53c19b27f75a39c7ead561a74b6"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0b05d53c19b27f75a39c7ead561a74b6">deviceIds</a> () const</td></tr>
<tr class="memdesc:a0b05d53c19b27f75a39c7ead561a74b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of all the connected devices.  <a href="struct_xs_control.html#a0b05d53c19b27f75a39c7ead561a74b6">More...</a><br /></td></tr>
<tr class="separator:a0b05d53c19b27f75a39c7ead561a74b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4347865a9df7b27d60aac0ed5115a5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4347865a9df7b27d60aac0ed5115a5e3">disabledOptions</a> () const</td></tr>
<tr class="memdesc:a4347865a9df7b27d60aac0ed5115a5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently explicitly disabled options.  <a href="struct_xs_control.html#a4347865a9df7b27d60aac0ed5115a5e3">More...</a><br /></td></tr>
<tr class="separator:a4347865a9df7b27d60aac0ed5115a5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83577827bf74812f0b38cdbaba1fb19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ac83577827bf74812f0b38cdbaba1fb19">dockDeviceId</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const</td></tr>
<tr class="memdesc:ac83577827bf74812f0b38cdbaba1fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of the dock device for the given <em>deviceId</em>.  <a href="struct_xs_control.html#ac83577827bf74812f0b38cdbaba1fb19">More...</a><br /></td></tr>
<tr class="separator:ac83577827bf74812f0b38cdbaba1fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1e3d3aadc8d6ead01a22116ffe628e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7a1e3d3aadc8d6ead01a22116ffe628e">enabledOptions</a> () const</td></tr>
<tr class="memdesc:a7a1e3d3aadc8d6ead01a22116ffe628e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently enabled options.  <a href="struct_xs_control.html#a7a1e3d3aadc8d6ead01a22116ffe628e">More...</a><br /></td></tr>
<tr class="separator:a7a1e3d3aadc8d6ead01a22116ffe628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abb5c877459bf6366400dd8031d5c23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7abb5c877459bf6366400dd8031d5c23">flushInputBuffers</a> ()</td></tr>
<tr class="memdesc:a7abb5c877459bf6366400dd8031d5c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of all devices.  <a href="struct_xs_control.html#a7abb5c877459bf6366400dd8031d5c23">More...</a><br /></td></tr>
<tr class="separator:a7abb5c877459bf6366400dd8031d5c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cd96488ce1b754f7443f6572c314fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a60cd96488ce1b754f7443f6572c314fa">getDeviceFromLocationId</a> (uint16_t locationId) const</td></tr>
<tr class="memdesc:a60cd96488ce1b754f7443f6572c314fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device of the device on the given <em>locationId</em>.  <a href="struct_xs_control.html#a60cd96488ce1b754f7443f6572c314fa">More...</a><br /></td></tr>
<tr class="separator:a60cd96488ce1b754f7443f6572c314fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c42a40e9578858d158701501e0a629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ad3c42a40e9578858d158701501e0a629">gotoConfig</a> ()</td></tr>
<tr class="memdesc:ad3c42a40e9578858d158701501e0a629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place all sensors connected through a serial port into Configuration Mode.  <a href="struct_xs_control.html#ad3c42a40e9578858d158701501e0a629">More...</a><br /></td></tr>
<tr class="separator:ad3c42a40e9578858d158701501e0a629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4c725b210645983288efcf79fbaf77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a9c4c725b210645983288efcf79fbaf77">gotoMeasurement</a> ()</td></tr>
<tr class="memdesc:a9c4c725b210645983288efcf79fbaf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place all sensors connected through a serial port into Measurement Mode.  <a href="struct_xs_control.html#a9c4c725b210645983288efcf79fbaf77">More...</a><br /></td></tr>
<tr class="separator:a9c4c725b210645983288efcf79fbaf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46434cd6ee141eb144585a102365c10e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a46434cd6ee141eb144585a102365c10e">isDeviceDocked</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const</td></tr>
<tr class="memdesc:a46434cd6ee141eb144585a102365c10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is docked.  <a href="struct_xs_control.html#a46434cd6ee141eb144585a102365c10e">More...</a><br /></td></tr>
<tr class="separator:a46434cd6ee141eb144585a102365c10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcac2b13afa8c57370b4f1b3971a9ce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8bcac2b13afa8c57370b4f1b3971a9ce">isDeviceWireless</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const</td></tr>
<tr class="memdesc:a8bcac2b13afa8c57370b4f1b3971a9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected.  <a href="struct_xs_control.html#a8bcac2b13afa8c57370b4f1b3971a9ce">More...</a><br /></td></tr>
<tr class="separator:a8bcac2b13afa8c57370b4f1b3971a9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce26299dc35a9bd4ee6941da2e59cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8ce26299dc35a9bd4ee6941da2e59cdb">lastHardwareError</a> () const</td></tr>
<tr class="memdesc:a8ce26299dc35a9bd4ee6941da2e59cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last hardware error code.  <a href="struct_xs_control.html#a8ce26299dc35a9bd4ee6941da2e59cdb">More...</a><br /></td></tr>
<tr class="separator:a8ce26299dc35a9bd4ee6941da2e59cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfee86128bea857fb2d2f4a960ca20f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aabfee86128bea857fb2d2f4a960ca20f">lastHardwareErrorDeviceId</a> () const</td></tr>
<tr class="separator:aabfee86128bea857fb2d2f4a960ca20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3979db861a602e5455ce7c8357f427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427">lastResult</a> () const</td></tr>
<tr class="memdesc:a2e3979db861a602e5455ce7c8357f427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427">More...</a><br /></td></tr>
<tr class="separator:a2e3979db861a602e5455ce7c8357f427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14cbf23892c0df0a10bdacdd99d7cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aa14cbf23892c0df0a10bdacdd99d7cf2">lastResultText</a> () const</td></tr>
<tr class="memdesc:aa14cbf23892c0df0a10bdacdd99d7cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accompanying error text for the value returned by <a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a>  <a href="struct_xs_control.html#aa14cbf23892c0df0a10bdacdd99d7cf2">More...</a><br /></td></tr>
<tr class="separator:aa14cbf23892c0df0a10bdacdd99d7cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700e2ba28d2710417b2e321520597a14"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a700e2ba28d2710417b2e321520597a14">loadFilterProfiles</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a700e2ba28d2710417b2e321520597a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load filter profile definitions from a settings file with the given <em>filename</em>.  <a href="struct_xs_control.html#a700e2ba28d2710417b2e321520597a14">More...</a><br /></td></tr>
<tr class="separator:a700e2ba28d2710417b2e321520597a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14babb4414bb25989f3224c7a300fc24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a14babb4414bb25989f3224c7a300fc24">mainDeviceCount</a> () const</td></tr>
<tr class="memdesc:a14babb4414bb25989f3224c7a300fc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of main devices.  <a href="struct_xs_control.html#a14babb4414bb25989f3224c7a300fc24">More...</a><br /></td></tr>
<tr class="separator:a14babb4414bb25989f3224c7a300fc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323c0d96891d19f492662b217ff37ed6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a323c0d96891d19f492662b217ff37ed6">mainDeviceIds</a> () const</td></tr>
<tr class="memdesc:a323c0d96891d19f492662b217ff37ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available main devices.  <a href="struct_xs_control.html#a323c0d96891d19f492662b217ff37ed6">More...</a><br /></td></tr>
<tr class="separator:a323c0d96891d19f492662b217ff37ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7854a2f373f4d8af61fb4f05da336b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7854a2f373f4d8af61fb4f05da336b2b">mainDevices</a> () const</td></tr>
<tr class="memdesc:a7854a2f373f4d8af61fb4f05da336b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface objects.  <a href="struct_xs_control.html#a7854a2f373f4d8af61fb4f05da336b2b">More...</a><br /></td></tr>
<tr class="separator:a7854a2f373f4d8af61fb4f05da336b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7afbf81e317983c6bfec40e1837048"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a2b7afbf81e317983c6bfec40e1837048">mtCount</a> () const</td></tr>
<tr class="memdesc:a2b7afbf81e317983c6bfec40e1837048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected MTs.  <a href="struct_xs_control.html#a2b7afbf81e317983c6bfec40e1837048">More...</a><br /></td></tr>
<tr class="separator:a2b7afbf81e317983c6bfec40e1837048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c40ef1b937926ef8178f173cab4f84"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a91c40ef1b937926ef8178f173cab4f84">mtDeviceIds</a> () const</td></tr>
<tr class="memdesc:a91c40ef1b937926ef8178f173cab4f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available MTs.  <a href="struct_xs_control.html#a91c40ef1b937926ef8178f173cab4f84">More...</a><br /></td></tr>
<tr class="separator:a91c40ef1b937926ef8178f173cab4f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6076a44725ba5f8bbe31fdcd4865585d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6076a44725ba5f8bbe31fdcd4865585d">openCustomPort</a> (int channelId, uint32_t channelLatency, bool detectRs485=false)</td></tr>
<tr class="memdesc:a6076a44725ba5f8bbe31fdcd4865585d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a custom communication channel.  <a href="struct_xs_control.html#a6076a44725ba5f8bbe31fdcd4865585d">More...</a><br /></td></tr>
<tr class="separator:a6076a44725ba5f8bbe31fdcd4865585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8016cd90e619844c9e70cffb9fca6a0b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8016cd90e619844c9e70cffb9fca6a0b">openImarPort_internal</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portname, <a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> baudrate, int imarType, uint32_t timeout=0)</td></tr>
<tr class="memdesc:a8016cd90e619844c9e70cffb9fca6a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel on serial port with the given <em>portname</em>.  <a href="struct_xs_control.html#a8016cd90e619844c9e70cffb9fca6a0b">More...</a><br /></td></tr>
<tr class="separator:a8016cd90e619844c9e70cffb9fca6a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19d4bbf1c8331a77c1583800314fb60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae19d4bbf1c8331a77c1583800314fb60">openLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:ae19d4bbf1c8331a77c1583800314fb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the log file with the given <em>filename</em>.  <a href="struct_xs_control.html#ae19d4bbf1c8331a77c1583800314fb60">More...</a><br /></td></tr>
<tr class="separator:ae19d4bbf1c8331a77c1583800314fb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcd5f3427b7509b07baf64650e56dbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd">openPort</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portname, <a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> baudrate, uint32_t timeout=0, bool detectRs485=false)</td></tr>
<tr class="memdesc:a0dcd5f3427b7509b07baf64650e56dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel on serial port with the given <em>portname</em>.  <a href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd">More...</a><br /></td></tr>
<tr class="separator:a0dcd5f3427b7509b07baf64650e56dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2f1637761664f1828e4d7895cdb453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ace2f1637761664f1828e4d7895cdb453">openPort</a> (int portNr, <a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> baudrate, uint32_t timeout=0, bool detectRs485=false)</td></tr>
<tr class="memdesc:ace2f1637761664f1828e4d7895cdb453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel to the given COM <em>portNr</em>.  <a href="struct_xs_control.html#ace2f1637761664f1828e4d7895cdb453">More...</a><br /></td></tr>
<tr class="separator:ace2f1637761664f1828e4d7895cdb453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bef49e962f8f86f5fecd909958c4718"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a5bef49e962f8f86f5fecd909958c4718">openPort</a> (<a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo, uint32_t timeout=0, bool detectRs485=false)</td></tr>
<tr class="memdesc:a5bef49e962f8f86f5fecd909958c4718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel using the details in the supplied XsPortInfo structure.  <a href="struct_xs_control.html#a5bef49e962f8f86f5fecd909958c4718">More...</a><br /></td></tr>
<tr class="separator:a5bef49e962f8f86f5fecd909958c4718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad344df7bb853909b6e240adb7a0d38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#acad344df7bb853909b6e240adb7a0d38">openPortWithCredentials</a> (<a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;id, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;key, uint32_t timeout=0)</td></tr>
<tr class="memdesc:acad344df7bb853909b6e240adb7a0d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel using the details in the supplied XsPortInfo structure using the supplied credentials.  <a href="struct_xs_control.html#acad344df7bb853909b6e240adb7a0d38">More...</a><br /></td></tr>
<tr class="separator:acad344df7bb853909b6e240adb7a0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8b49db27bd202e7b2f5d24468ec34bd1">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="struct_xs_control.html#a8b49db27bd202e7b2f5d24468ec34bd1">More...</a><br /></td></tr>
<tr class="separator:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcb04c842fdab3f1cd880e26c673e77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a3fcb04c842fdab3f1cd880e26c673e77">setInitialPositionLLA</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;lla)</td></tr>
<tr class="memdesc:a3fcb04c842fdab3f1cd880e26c673e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current GNSS position of the system.  <a href="struct_xs_control.html#a3fcb04c842fdab3f1cd880e26c673e77">More...</a><br /></td></tr>
<tr class="separator:a3fcb04c842fdab3f1cd880e26c673e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161b1aab842c36ac535ef814a3883ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8">setOptions</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> enable, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> disable)</td></tr>
<tr class="memdesc:a161b1aab842c36ac535ef814a3883ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peristently enable or disable options.  <a href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8">More...</a><br /></td></tr>
<tr class="separator:a161b1aab842c36ac535ef814a3883ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4347410af4204ad77de2f1eafba8b529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4347410af4204ad77de2f1eafba8b529">setOptionsForce</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> enabled)</td></tr>
<tr class="memdesc:a4347410af4204ad77de2f1eafba8b529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peristently enable or disable options.  <a href="struct_xs_control.html#a4347410af4204ad77de2f1eafba8b529">More...</a><br /></td></tr>
<tr class="separator:a4347410af4204ad77de2f1eafba8b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1622bed2a39870357796a242e40b92d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a1622bed2a39870357796a242e40b92d5">startRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portName)</td></tr>
<tr class="memdesc:a1622bed2a39870357796a242e40b92d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts restore communication procedure.  <a href="struct_xs_control.html#a1622bed2a39870357796a242e40b92d5">More...</a><br /></td></tr>
<tr class="separator:a1622bed2a39870357796a242e40b92d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d34fea148815ca9b9c49c066c962847"><td class="memItemLeft" align="right" valign="top"><a id="a5d34fea148815ca9b9c49c066c962847"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a5d34fea148815ca9b9c49c066c962847">stopRestoreCommunication</a> ()</td></tr>
<tr class="memdesc:a5d34fea148815ca9b9c49c066c962847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops restore communication procedure. <br /></td></tr>
<tr class="separator:a5d34fea148815ca9b9c49c066c962847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb8fa1b3dbed12399023cc1defb1066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4bb8fa1b3dbed12399023cc1defb1066">transmissionReceived</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> &amp;data)</td></tr>
<tr class="memdesc:a4bb8fa1b3dbed12399023cc1defb1066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed data coming back from an Xsens device over a custom channel into XDA.  <a href="struct_xs_control.html#a4bb8fa1b3dbed12399023cc1defb1066">More...</a><br /></td></tr>
<tr class="separator:a4bb8fa1b3dbed12399023cc1defb1066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_callback_manager_xda"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_callback_manager_xda')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a></td></tr>
<tr class="memitem:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ae286810bd0b4d20678987b354fa13d29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ae286810bd0b4d20678987b354fa13d29">CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initializes the callback list. <br /></td></tr>
<tr class="separator:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5910d161433653494a59986643233cf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5910d161433653494a59986643233cf6">~CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, clears the callback list. <br /></td></tr>
<tr class="separator:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler to the list.  <a href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">More...</a><br /></td></tr>
<tr class="separator:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">addChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a chained manager to the list.  <a href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">More...</a><br /></td></tr>
<tr class="separator:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback list.  <a href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">More...</a><br /></td></tr>
<tr class="separator:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="acb7c60244a13f84ca7cc06efa50d9685"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acb7c60244a13f84ca7cc06efa50d9685">clearChainedManagers</a> ()</td></tr>
<tr class="memdesc:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the chained manager list. <br /></td></tr>
<tr class="separator:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">copyCallbackHandlersFrom</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from <em>cm</em> into this manager.  <a href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">More...</a><br /></td></tr>
<tr class="separator:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">copyCallbackHandlersTo</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from this manager into <em>cm</em>.  <a href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">More...</a><br /></td></tr>
<tr class="separator:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af2827956387a56712723e9200882179c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2827956387a56712723e9200882179c">onAllBufferedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5f103ff688afdeef381eedd6100331d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5f103ff688afdeef381eedd6100331d2">onAllDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5e64d70ce299958605b6149049e045ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5e64d70ce299958605b6149049e045ef">onAllLiveDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a4c0aa7e3be74595cef490b98d1520d1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a4c0aa7e3be74595cef490b98d1520d1e">onAllRecordedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6" title="Called when new data has been received for devices connected to the same main device in a recording s...">XsCallback::onAllRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ad4c8eb08edd64025b3e9405415b38834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad4c8eb08edd64025b3e9405415b38834">onBufferedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399" title="Called when XDA has a data packet that could be written to a log file.">XsCallback::onBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a312575546ab44f788dd3961477ba0e7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a312575546ab44f788dd3961477ba0e7f">onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState) override</td></tr>
<tr class="memdesc:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40" title="Called when XDA has detected a change in the connectivity state of a device.">XsCallback::onConnectivityChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="acc815adc25af17f24207573afa9c94da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acc815adc25af17f24207573afa9c94da">onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a7738059783802ad5e1278108a467ccc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7738059783802ad5e1278108a467ccc2">onDataUnavailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId) override</td></tr>
<tr class="memdesc:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga89d308afd509c0325b4cdb622fd9e645" title="Called when XDA detects that data is forever unavailable.">XsCallback::onDataUnavailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a1409c965b88efc664a2ef7d36e5490f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a1409c965b88efc664a2ef7d36e5490f4">onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState) override</td></tr>
<tr class="memdesc:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0" title="Called when a device&#39;s state has changed (ie config mode, measurement mode, recording mode)">XsCallback::onDeviceStateChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a3a65ae9866cb7a9e8ab11dcfeca1572f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a3a65ae9866cb7a9e8ab11dcfeca1572f">onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error) override</td></tr>
<tr class="memdesc:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onError() callback forwarding function. <br /></td></tr>
<tr class="separator:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a01afaba0ea9f47b5c4f490ee7dba7364"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364">onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request) override</td></tr>
<tr class="memdesc:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5" title="Called when an information request has resulted in a response.">XsCallback::onInfoResponse()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="aebd995bd1dc83e69822f874eabb0c4fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aebd995bd1dc83e69822f874eabb0c4fa">onLiveDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet) override</td></tr>
<tr class="memdesc:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af81b39fa94f8086d9682df2e53ea5e1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af81b39fa94f8086d9682df2e53ea5e1e">onMessageDetected</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage) override</td></tr>
<tr class="memdesc:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a760e93d7f7142fd22c7e134c4cea5f72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a760e93d7f7142fd22c7e134c4cea5f72">onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a73ec10bd8e7cf2df6b4136ad0ac9701e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a73ec10bd8e7cf2df6b4136ad0ac9701e">onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageSentToDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a79ae15c19c791af165c842441993660c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a79ae15c19c791af165c842441993660c">onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last) override</td></tr>
<tr class="memdesc:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e" title="Called when XDA detects that packets have been missed.">XsCallback::onMissedPackets()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="afdeff1e1697266d82f232642aef0cae9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#afdeff1e1697266d82f232642aef0cae9">onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onNonDataMessage() callback forwarding function. <br /></td></tr>
<tr class="separator:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a840ce749572d8997e33ee8f860db97c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a840ce749572d8997e33ee8f860db97c7">onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier) override</td></tr>
<tr class="memdesc:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59" title="Called when a long-duration operation has made some progress or has completed. Examples include loadL...">XsCallback::onProgressUpdated()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5b6beccc0e4760b652b7be01e859e465"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5b6beccc0e4760b652b7be01e859e465">onRecordedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14" title="Called when new data has been received from a device in a recording state or read from a file....">XsCallback::onRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af91bb23b63beb62d085182044abb30a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af91bb23b63beb62d085182044abb30a7">onRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result) override</td></tr>
<tr class="memdesc:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onRestoreCommunication callback forwarding function. <br /></td></tr>
<tr class="separator:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">onTransmissionRequest</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data) override</td></tr>
<tr class="memdesc:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">More...</a><br /></td></tr>
<tr class="separator:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a7471f499ee52bb189ef4e3917a20e5d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7471f499ee52bb189ef4e3917a20e5d0">onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev) override</td></tr>
<tr class="memdesc:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a" title="Called when a wakeup message has been received from a device. This indicates that the device has just...">XsCallback::onWakeupReceived()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ad510877b529df7a85fbc5d601c2fad76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad510877b529df7a85fbc5d601c2fad76">onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message) override</td></tr>
<tr class="memdesc:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290" title="Called when XDA has a message that could be written to a log file.">XsCallback::onWriteMessageToLogFile()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">More...</a><br /></td></tr>
<tr class="separator:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">removeChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove achained manager from the list.  <a href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">More...</a><br /></td></tr>
<tr class="separator:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_xs_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_xs_callback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_xs_callback.html">XsCallback</a></td></tr>
<tr class="memitem:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top"><a id="a491695016a32d02a31e2f4bda826ef47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a491695016a32d02a31e2f4bda826ef47">XsCallback</a> ()</td></tr>
<tr class="memdesc:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">~XsCallback</a> ()</td></tr>
<tr class="memdesc:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">More...</a><br /></td></tr>
<tr class="separator:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aee6e97e9dad8eea2681994d9d31cd272"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272">resultText</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> resultCode)</td></tr>
<tr class="memdesc:aee6e97e9dad8eea2681994d9d31cd272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptive text for the given <em>resultCode</em>.  <a href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272">More...</a><br /></td></tr>
<tr class="separator:aee6e97e9dad8eea2681994d9d31cd272"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab7b7ba11fac869d017c163f185398684"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ab7b7ba11fac869d017c163f185398684">addMasterDevice</a> (<a class="el" href="struct_communicator.html">Communicator</a> *communicator)</td></tr>
<tr class="memdesc:ab7b7ba11fac869d017c163f185398684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a device as master. The new master will be owned by this.  <a href="struct_xs_control.html#ab7b7ba11fac869d017c163f185398684">More...</a><br /></td></tr>
<tr class="separator:ab7b7ba11fac869d017c163f185398684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7650d9a9b78fe4a7e061484ed7ccc910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7650d9a9b78fe4a7e061484ed7ccc910">closePortByIndex</a> (uint32_t index)</td></tr>
<tr class="memdesc:a7650d9a9b78fe4a7e061484ed7ccc910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a serial communication port by <em>index</em>.  <a href="struct_xs_control.html#a7650d9a9b78fe4a7e061484ed7ccc910">More...</a><br /></td></tr>
<tr class="separator:a7650d9a9b78fe4a7e061484ed7ccc910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821541d2aff34fcadfe060de9bddabb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a821541d2aff34fcadfe060de9bddabb3">findDevice</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const</td></tr>
<tr class="memdesc:a821541d2aff34fcadfe060de9bddabb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the device info of the supplied <em>deviceId</em> and return a pointer to the item in the list.  <a href="struct_xs_control.html#a821541d2aff34fcadfe060de9bddabb3">More...</a><br /></td></tr>
<tr class="separator:a821541d2aff34fcadfe060de9bddabb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591dd80fe8c99b96cd2d9c0b53955573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a591dd80fe8c99b96cd2d9c0b53955573">findXbusInterface</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const</td></tr>
<tr class="memdesc:a591dd80fe8c99b96cd2d9c0b53955573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the xs3 info of the given id.  <a href="struct_xs_control.html#a591dd80fe8c99b96cd2d9c0b53955573">More...</a><br /></td></tr>
<tr class="separator:a591dd80fe8c99b96cd2d9c0b53955573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872614e715327f89f04f51e1d821a817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a872614e715327f89f04f51e1d821a817">findXbusInterface</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portInfo) const</td></tr>
<tr class="memdesc:a872614e715327f89f04f51e1d821a817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the XBUS interface in a port information object.  <a href="struct_xs_control.html#a872614e715327f89f04f51e1d821a817">More...</a><br /></td></tr>
<tr class="separator:a872614e715327f89f04f51e1d821a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988fdc7dc6d6e83657bf83c627e1b338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a988fdc7dc6d6e83657bf83c627e1b338">findXbusInterface</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portName) const</td></tr>
<tr class="memdesc:a988fdc7dc6d6e83657bf83c627e1b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the XBUS interface in a port.  <a href="struct_xs_control.html#a988fdc7dc6d6e83657bf83c627e1b338">More...</a><br /></td></tr>
<tr class="separator:a988fdc7dc6d6e83657bf83c627e1b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb67a6378974b510f906759a4dc2e8d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aabb67a6378974b510f906759a4dc2e8d">removeExistingDevice</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> const &amp;deviceId)</td></tr>
<tr class="memdesc:aabb67a6378974b510f906759a4dc2e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an existing device. Because it was detected somewhere else.  <a href="struct_xs_control.html#aabb67a6378974b510f906759a4dc2e8d">More...</a><br /></td></tr>
<tr class="separator:aabb67a6378974b510f906759a4dc2e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba342544f9f4d7d6a64a0742b45f401a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aba342544f9f4d7d6a64a0742b45f401a">setPersistentSettings</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:aba342544f9f4d7d6a64a0742b45f401a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the persistent settings to a (newly created) device.  <a href="struct_xs_control.html#aba342544f9f4d7d6a64a0742b45f401a">More...</a><br /></td></tr>
<tr class="separator:aba342544f9f4d7d6a64a0742b45f401a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128fb9eaa69e661a24a695499b9f5802"><td class="memItemLeft" align="right" valign="top"><a id="a128fb9eaa69e661a24a695499b9f5802"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a128fb9eaa69e661a24a695499b9f5802">updateRecordingState</a> ()</td></tr>
<tr class="memdesc:a128fb9eaa69e661a24a695499b9f5802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are devices in a recording state and update m_recording accordingly. <br /></td></tr>
<tr class="separator:a128fb9eaa69e661a24a695499b9f5802"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8b7b5a68a3af7c9626658b03ca143da4"><td class="memItemLeft" align="right" valign="top"><a id="a8b7b5a68a3af7c9626658b03ca143da4"></a>
<a class="el" href="class_broadcast_device.html">BroadcastDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8b7b5a68a3af7c9626658b03ca143da4">m_broadcaster</a></td></tr>
<tr class="memdesc:a8b7b5a68a3af7c9626658b03ca143da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The broadcast device object. <br /></td></tr>
<tr class="separator:a8b7b5a68a3af7c9626658b03ca143da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccf5f6a9e65be50b3b05eb4f63bd220"><td class="memItemLeft" align="right" valign="top"><a id="a3ccf5f6a9e65be50b3b05eb4f63bd220"></a>
<a class="el" href="class_xda_communicator_factory.html">XdaCommunicatorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a3ccf5f6a9e65be50b3b05eb4f63bd220">m_communicatorFactory</a></td></tr>
<tr class="memdesc:a3ccf5f6a9e65be50b3b05eb4f63bd220"><td class="mdescLeft">&#160;</td><td class="mdescRight">The communicator factory object. <br /></td></tr>
<tr class="separator:a3ccf5f6a9e65be50b3b05eb4f63bd220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50eb08650688f288faa402f2ae1087e"><td class="memItemLeft" align="right" valign="top"><a id="ae50eb08650688f288faa402f2ae1087e"></a>
<a class="el" href="class_device_factory.html">DeviceFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae50eb08650688f288faa402f2ae1087e">m_deviceFactory</a></td></tr>
<tr class="memdesc:ae50eb08650688f288faa402f2ae1087e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device factory object. <br /></td></tr>
<tr class="separator:ae50eb08650688f288faa402f2ae1087e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72bceee981b2855905f945cf7d990bb"><td class="memItemLeft" align="right" valign="top"><a id="ae72bceee981b2855905f945cf7d990bb"></a>
std::vector&lt; <a class="el" href="struct_xs_device.html">XsDevice</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae72bceee981b2855905f945cf7d990bb">m_deviceList</a></td></tr>
<tr class="memdesc:ae72bceee981b2855905f945cf7d990bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This list contains device-information and cached data per device. <br /></td></tr>
<tr class="separator:ae72bceee981b2855905f945cf7d990bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba87805641a8caa6c0d52cdc9787906"><td class="memItemLeft" align="right" valign="top"><a id="a5ba87805641a8caa6c0d52cdc9787906"></a>
<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a5ba87805641a8caa6c0d52cdc9787906">m_lastHwError</a></td></tr>
<tr class="memdesc:a5ba87805641a8caa6c0d52cdc9787906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the last serious error reported by CMT3. <br /></td></tr>
<tr class="separator:a5ba87805641a8caa6c0d52cdc9787906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3eb5f8d433adcd407733a88ab0a465"><td class="memItemLeft" align="right" valign="top"><a id="a7b3eb5f8d433adcd407733a88ab0a465"></a>
<a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7b3eb5f8d433adcd407733a88ab0a465">m_lastHwErrorDeviceId</a></td></tr>
<tr class="memdesc:a7b3eb5f8d433adcd407733a88ab0a465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> ID of the device that caused the last hardware error. <br /></td></tr>
<tr class="separator:a7b3eb5f8d433adcd407733a88ab0a465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084e7c060f3435aa89fdb7a74aec3ab0"><td class="memItemLeft" align="right" valign="top"><a id="a084e7c060f3435aa89fdb7a74aec3ab0"></a>
<a class="el" href="class_last_result_manager.html">LastResultManager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a084e7c060f3435aa89fdb7a74aec3ab0">m_lastResult</a></td></tr>
<tr class="memdesc:a084e7c060f3435aa89fdb7a74aec3ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last result of an operation. <br /></td></tr>
<tr class="separator:a084e7c060f3435aa89fdb7a74aec3ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34710bbbe0e22927d49934c05e150b0"><td class="memItemLeft" align="right" valign="top"><a id="ae34710bbbe0e22927d49934c05e150b0"></a>
<a class="el" href="struct_xs_vector3.html">XsVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae34710bbbe0e22927d49934c05e150b0">m_latLonAlt</a></td></tr>
<tr class="memdesc:ae34710bbbe0e22927d49934c05e150b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector contains the latitude, longitude and altitude. <br /></td></tr>
<tr class="separator:ae34710bbbe0e22927d49934c05e150b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5f9a5d93a8c43f83b6b2201e4df419"><td class="memItemLeft" align="right" valign="top"><a id="a4c5f9a5d93a8c43f83b6b2201e4df419"></a>
<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4c5f9a5d93a8c43f83b6b2201e4df419">m_optionsDisable</a></td></tr>
<tr class="memdesc:a4c5f9a5d93a8c43f83b6b2201e4df419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contsins all disabled options. <br /></td></tr>
<tr class="separator:a4c5f9a5d93a8c43f83b6b2201e4df419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b2b273abfb9234a045e5632be417e4"><td class="memItemLeft" align="right" valign="top"><a id="a01b2b273abfb9234a045e5632be417e4"></a>
<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a01b2b273abfb9234a045e5632be417e4">m_optionsEnable</a></td></tr>
<tr class="memdesc:a01b2b273abfb9234a045e5632be417e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all enable options. <br /></td></tr>
<tr class="separator:a01b2b273abfb9234a045e5632be417e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968279830f6f6138bfbf5ff474fc1918"><td class="memItemLeft" align="right" valign="top"><a id="a968279830f6f6138bfbf5ff474fc1918"></a>
<a class="el" href="classxsens_1_1_mutex_read_write.html">xsens::MutexReadWrite</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a968279830f6f6138bfbf5ff474fc1918">m_portMutex</a></td></tr>
<tr class="memdesc:a968279830f6f6138bfbf5ff474fc1918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls access to the serial ports, also used to suspend the thread. <br /></td></tr>
<tr class="separator:a968279830f6f6138bfbf5ff474fc1918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e371a75c1550d98ee5544abd8496c"><td class="memItemLeft" align="right" valign="top"><a id="a544e371a75c1550d98ee5544abd8496c"></a>
std::map&lt; int, <a class="el" href="class_proxy_communicator.html">ProxyCommunicator</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a544e371a75c1550d98ee5544abd8496c">m_proxyChannels</a></td></tr>
<tr class="memdesc:a544e371a75c1550d98ee5544abd8496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This map contains the proxy channels. <br /></td></tr>
<tr class="separator:a544e371a75c1550d98ee5544abd8496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefd4551d1ef6f79aeab607dfcc0533d"><td class="memItemLeft" align="right" valign="top"><a id="adefd4551d1ef6f79aeab607dfcc0533d"></a>
volatile std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#adefd4551d1ef6f79aeab607dfcc0533d">m_recording</a></td></tr>
<tr class="memdesc:adefd4551d1ef6f79aeab607dfcc0533d"><td class="mdescLeft">&#160;</td><td class="mdescRight">AwindaStationIndication of threads started or not. <br /></td></tr>
<tr class="separator:adefd4551d1ef6f79aeab607dfcc0533d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159646155fd7dce199dfaf379ce79e46"><td class="memItemLeft" align="right" valign="top"><a id="a159646155fd7dce199dfaf379ce79e46"></a>
<a class="el" href="class_restore_communication.html">RestoreCommunication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a159646155fd7dce199dfaf379ce79e46">m_restoreCommunication</a></td></tr>
<tr class="memdesc:a159646155fd7dce199dfaf379ce79e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The restore communication object. <br /></td></tr>
<tr class="separator:a159646155fd7dce199dfaf379ce79e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895ca8eef5396ccd5ae27e9991a10984"><td class="memItemLeft" align="right" valign="top"><a id="a895ca8eef5396ccd5ae27e9991a10984"></a>
<a class="el" href="classxsens_1_1_mutex.html">xsens::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a895ca8eef5396ccd5ae27e9991a10984">m_runMutex</a></td></tr>
<tr class="memdesc:a895ca8eef5396ccd5ae27e9991a10984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always held by the thread when it is running. <br /></td></tr>
<tr class="separator:a895ca8eef5396ccd5ae27e9991a10984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21c4d6fcb706f14fa9dc365c402f3bd"><td class="memItemLeft" align="right" valign="top"><a id="af21c4d6fcb706f14fa9dc365c402f3bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#af21c4d6fcb706f14fa9dc365c402f3bd">m_useFakeMessages</a></td></tr>
<tr class="memdesc:af21c4d6fcb706f14fa9dc365c402f3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean variable for enabling/disabling the use of fake messages. <br /></td></tr>
<tr class="separator:af21c4d6fcb706f14fa9dc365c402f3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a273020f4544f6e0fb7b4318373e37571"><td class="memItemLeft" align="right" valign="top"><a id="a273020f4544f6e0fb7b4318373e37571"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>BroadcastDevice</b></td></tr>
<tr class="separator:a273020f4544f6e0fb7b4318373e37571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925aa2d8ae053bf57e83430392189b34"><td class="memItemLeft" align="right" valign="top"><a id="a925aa2d8ae053bf57e83430392189b34"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>BroadcastForwardFunc</b></td></tr>
<tr class="separator:a925aa2d8ae053bf57e83430392189b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_struct_xs_callback_plain_c"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_struct_xs_callback_plain_c')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a></td></tr>
<tr class="memitem:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">m_onAllBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">More...</a><br /></td></tr>
<tr class="separator:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">m_onAllDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">More...</a><br /></td></tr>
<tr class="separator:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">m_onAllLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">More...</a><br /></td></tr>
<tr class="separator:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">m_onAllRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">More...</a><br /></td></tr>
<tr class="separator:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">m_onBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">More...</a><br /></td></tr>
<tr class="separator:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">More...</a><br /></td></tr>
<tr class="separator:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">More...</a><br /></td></tr>
<tr class="separator:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">m_onDataUnavailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable.  <a href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">More...</a><br /></td></tr>
<tr class="separator:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">More...</a><br /></td></tr>
<tr class="separator:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">More...</a><br /></td></tr>
<tr class="separator:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">More...</a><br /></td></tr>
<tr class="separator:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">m_onLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">More...</a><br /></td></tr>
<tr class="separator:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">m_onMessageDetected</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">More...</a><br /></td></tr>
<tr class="separator:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">More...</a><br /></td></tr>
<tr class="separator:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">More...</a><br /></td></tr>
<tr class="separator:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">More...</a><br /></td></tr>
<tr class="separator:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">More...</a><br /></td></tr>
<tr class="separator:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">More...</a><br /></td></tr>
<tr class="separator:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">m_onRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">More...</a><br /></td></tr>
<tr class="separator:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">m_onRestoreCommunication</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occurred.  <a href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">More...</a><br /></td></tr>
<tr class="separator:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">m_onTransmissionRequest</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">More...</a><br /></td></tr>
<tr class="separator:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">More...</a><br /></td></tr>
<tr class="separator:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">More...</a><br /></td></tr>
<tr class="separator:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>High level Motion Tracker (MT) management class. </p>
<p>CMT version 2 and higher do not use the explicit error codes that CMT version 1 used. Most functions return a boolean indicating success, a null-object, empty lists or nothing at all. In some cases more in-depth knowledge of the last error is required. For these occasions, use <a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a> or <a class="el" href="struct_xs_control.html#aa14cbf23892c0df0a10bdacdd99d7cf2" title="Get the accompanying error text for the value returned by lastResult()">lastResultText()</a> to find out what exactly went wrong.</p>
<dl class="section note"><dt>Note</dt><dd>This object cannot be copied. The copy constructor has been disabled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cinterface.html">C Interface</a> For the C interface functions. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4581ed8c305367d1d4df972b8d8ff1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4581ed8c305367d1d4df972b8d8ff1c8">&#9670;&nbsp;</a></span>XsControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::XsControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Xsens Device API control object. </p>
<p>Construct a new Xsens Device API control object that can be used to open ports, files, etc. </p><dl class="section return"><dt>Returns</dt><dd>The newly constructed <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object </dd></dl>

</div>
</div>
<a id="a370ec5f19b1c42b23d9d7abd453787c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370ec5f19b1c42b23d9d7abd453787c4">&#9670;&nbsp;</a></span>~XsControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::~XsControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy this <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object. </p>
<p>All connected devices are put in config mode. All serial ports and files are subsequently closed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a5b22e73c092c0206e766d8e37ff0836f" title="Close all ports and files.">close()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a189065247d7fb3758a355c403c68866d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189065247d7fb3758a355c403c68866d">&#9670;&nbsp;</a></span>addCallbackHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a callback handler to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>

</div>
</div>
<a id="ab7b7ba11fac869d017c163f185398684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b7ba11fac869d017c163f185398684">&#9670;&nbsp;</a></span>addMasterDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::addMasterDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td>
          <td class="paramname"><em>communicator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a device as master. The new master will be owned by this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">communicator</td><td>the <a class="el" href="struct_communicator.html" title="A base struct for a communication interface.">Communicator</a> for the created device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>communicator is a pointer to a dynamically allocated <a class="el" href="struct_communicator.html" title="A base struct for a communication interface.">Communicator</a>. The created device will take ownership of the communicator. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created device. </dd></dl>

</div>
</div>
<a id="a0b1f958d74b3969deb4f82cb888648f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1f958d74b3969deb4f82cb888648f1">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the broadcast device. </p>
<p>The broadcast device can be used to apply an operation to all connected devices at once (if they support it) </p><dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer representing the broadcast device </dd></dl>

</div>
</div>
<a id="a30f24c9ba286897b176f4fb8efd0f285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f24c9ba286897b176f4fb8efd0f285">&#9670;&nbsp;</a></span>clearCallbackHandlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the callback handler list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all connected devices as well (true, default) or just the callback handlers of the XsControl object (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09a38dfa34e345ac68d4ebf2734658df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a38dfa34e345ac68d4ebf2734658df">&#9670;&nbsp;</a></span>clearHardwareError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::clearHardwareError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the last hardware error. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a8ce26299dc35a9bd4ee6941da2e59cdb" title="Get the last hardware error code.">lastHardwareError()</a>; </dd></dl>

</div>
</div>
<a id="a5b22e73c092c0206e766d8e37ff0836f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b22e73c092c0206e766d8e37ff0836f">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close all ports and files. </p>
<p>All devices are put in config mode before the serial port is closed. </p>

</div>
</div>
<a id="a90cfd08f3e7c65b057062bcbed1f425b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cfd08f3e7c65b057062bcbed1f425b">&#9670;&nbsp;</a></span>closeCustomPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closeCustomPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a custom communication channel. </p>
<dl class="section note"><dt>Note</dt><dd>When closing a custom channel the device will not be switched to config mode. This must be done manually </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a64a1fd038c9b569596e2ff48aaad39be" title="Put the device in config mode.">XsDevice::gotoConfig</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user-provided identifier of the channel to close. This identifier must match with the one used to open the port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6076a44725ba5f8bbe31fdcd4865585d" title="Open a custom communication channel.">openCustomPort</a> </dd></dl>

</div>
</div>
<a id="aee2a3ac5d55588c89de12347b17304a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2a3ac5d55588c89de12347b17304a2">&#9670;&nbsp;</a></span>closePort() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the port that is used for communication with the given <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The device ID to clos eth port for. When 0, the first available port is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the port hosts multiple devices, this function will make all devices connected to the port invalid. </dd></dl>

</div>
</div>
<a id="a16ce0525bfbd2726822d8d04306f8ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ce0525bfbd2726822d8d04306f8ba3">&#9670;&nbsp;</a></span>closePort() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the serial port that matches <em>portinfo</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>A port information structure that contains the name of the port to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79" title="Close the serial port with the given portname.">closePort(const XsString&amp;)</a> </dd></dl>

</div>
</div>
<a id="a9b3617d4a55cf48ddf7257788e1d5a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3617d4a55cf48ddf7257788e1d5a79">&#9670;&nbsp;</a></span>closePort() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the serial port with the given <em>portname</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portname</td><td>the name of the port to close (e.g. COM1 on Windows, /dev/ttyUSB0 on Linux) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47afe51569172239121d6f0520b93d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47afe51569172239121d6f0520b93d6e">&#9670;&nbsp;</a></span>closePort() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the serial port with the given <em>portNr</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portNr</td><td>The COM port number of the port that should be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only available on Windows systems </dd></dl>

</div>
</div>
<a id="a0525d061264b6622fc2aa68aff592746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0525d061264b6622fc2aa68aff592746">&#9670;&nbsp;</a></span>closePort() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the device port with the given <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>. </p>
<p>All connected devices are put in config mode before the port is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> obtained with the <a class="el" href="struct_xs_control.html#a908f5a025aef35e11a4e4583eb0c55a8" title="Returns the XsDevice interface object associated with the supplied deviceId.">device()</a> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a908f5a025aef35e11a4e4583eb0c55a8" title="Returns the XsDevice interface object associated with the supplied deviceId.">device()</a> </dd></dl>

</div>
</div>
<a id="a7650d9a9b78fe4a7e061484ed7ccc910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7650d9a9b78fe4a7e061484ed7ccc910">&#9670;&nbsp;</a></span>closePortByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePortByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close a serial communication port by <em>index</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of a device from a device list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53abcb328a487f53f2901ddfcd366031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53abcb328a487f53f2901ddfcd366031">&#9670;&nbsp;</a></span>customPortInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> XsControl::customPortInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the port information for a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user-provided identifier of the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The port info for the given channel </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6076a44725ba5f8bbe31fdcd4865585d" title="Open a custom communication channel.">openCustomPort</a> </dd></dl>

</div>
</div>
<a id="a908f5a025aef35e11a4e4583eb0c55a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908f5a025aef35e11a4e4583eb0c55a8">&#9670;&nbsp;</a></span>device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::device </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface object associated with the supplied <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The ID of the device to return, 0 to return the first available main device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> attached to the <em>deviceId</em> or 0 if the device was not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a0b1f958d74b3969deb4f82cb888648f1" title="Returns the broadcast device.">broadcast()</a> </dd></dl>

</div>
</div>
<a id="a93286830447b6f512e189adb328c51b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93286830447b6f512e189adb328c51b7">&#9670;&nbsp;</a></span>deviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::deviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of connected devices. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of connected devices </dd></dl>

</div>
</div>
<a id="a0b05d53c19b27f75a39c7ead561a74b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b05d53c19b27f75a39c7ead561a74b6">&#9670;&nbsp;</a></span>deviceIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::deviceIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of all the connected devices. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the device IDs of all the connected devices. </dd></dl>

</div>
</div>
<a id="a4347865a9df7b27d60aac0ed5115a5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4347865a9df7b27d60aac0ed5115a5e3">&#9670;&nbsp;</a></span>disabledOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> XsControl::disabledOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the currently explicitly disabled options. </p>
<dl class="section return"><dt>Returns</dt><dd>The options that are set to be explicitly disabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8" title="Peristently enable or disable options.">setOptions</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a7a1e3d3aadc8d6ead01a22116ffe628e" title="Return the currently enabled options.">enabledOptions</a> </dd></dl>

</div>
</div>
<a id="ac83577827bf74812f0b38cdbaba1fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83577827bf74812f0b38cdbaba1fb19">&#9670;&nbsp;</a></span>dockDeviceId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsControl::dockDeviceId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device ID of the dock device for the given <em>deviceId</em>. </p>
<p>This function returns the ID of the docking station that deviceId is plugged into. If the docking station itself is not an open port in this <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> or the device is not plugged into a docking station, the function will return a 0 id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to find the dock parent for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the device that has <em>deviceId</em> docked</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a46434cd6ee141eb144585a102365c10e" title="Test if the given deviceId is docked.">isDeviceDocked</a> </dd></dl>

</div>
</div>
<a id="a7a1e3d3aadc8d6ead01a22116ffe628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1e3d3aadc8d6ead01a22116ffe628e">&#9670;&nbsp;</a></span>enabledOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> XsControl::enabledOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the currently enabled options. </p>
<dl class="section return"><dt>Returns</dt><dd>The options that are set to be enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8" title="Peristently enable or disable options.">setOptions</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a4347865a9df7b27d60aac0ed5115a5e3" title="Return the currently explicitly disabled options.">disabledOptions</a> </dd></dl>

</div>
</div>
<a id="a821541d2aff34fcadfe060de9bddabb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821541d2aff34fcadfe060de9bddabb3">&#9670;&nbsp;</a></span>findDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::findDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the device info of the supplied <em>deviceId</em> and return a pointer to the item in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the device ID to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device matching <em>deviceId</em>, NULL otherwise. On failure <a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a> is set. </dd></dl>

</div>
</div>
<a id="a591dd80fe8c99b96cd2d9c0b53955573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591dd80fe8c99b96cd2d9c0b53955573">&#9670;&nbsp;</a></span>findXbusInterface() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_communicator.html">Communicator</a> * XsControl::findXbusInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the xs3 info of the given id. </p>
<p>Searches for the XBUS interface in a device object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The ID of device object to search in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found communication interface </dd></dl>

</div>
</div>
<a id="a872614e715327f89f04f51e1d821a817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872614e715327f89f04f51e1d821a817">&#9670;&nbsp;</a></span>findXbusInterface() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_communicator.html">Communicator</a> * XsControl::findXbusInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portInfo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the XBUS interface in a port information object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portInfo</td><td>The port information object to search in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found communication interface </dd></dl>

</div>
</div>
<a id="a988fdc7dc6d6e83657bf83c627e1b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988fdc7dc6d6e83657bf83c627e1b338">&#9670;&nbsp;</a></span>findXbusInterface() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_communicator.html">Communicator</a> * XsControl::findXbusInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the XBUS interface in a port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portName</td><td>The name of port to search in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found communication interface </dd></dl>

</div>
</div>
<a id="a7abb5c877459bf6366400dd8031d5c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abb5c877459bf6366400dd8031d5c23">&#9670;&nbsp;</a></span>flushInputBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::flushInputBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the inbound data buffers of all devices. </p>

</div>
</div>
<a id="a60cd96488ce1b754f7443f6572c314fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cd96488ce1b754f7443f6572c314fa">&#9670;&nbsp;</a></span>getDeviceFromLocationId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::getDeviceFromLocationId </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>locationId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device of the device on the given <em>locationId</em>. </p>
<p>If the location ID is not found, the lastResult value is set and the function returns a nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locationId</td><td>the location ID of the device we're looking for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the device for <em>locationId</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>

</div>
</div>
<a id="ad3c42a40e9578858d158701501e0a629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c42a40e9578858d158701501e0a629">&#9670;&nbsp;</a></span>gotoConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::gotoConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place all sensors connected through a serial port into Configuration Mode. </p>
<p>This function is called before <a class="el" href="struct_xs_control.html#a5b22e73c092c0206e766d8e37ff0836f" title="Close all ports and files.">close()</a> in the destructor of the class. /sa <a class="el" href="struct_xs_control.html#a5b22e73c092c0206e766d8e37ff0836f" title="Close all ports and files.">close()</a> </p>

</div>
</div>
<a id="a9c4c725b210645983288efcf79fbaf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4c725b210645983288efcf79fbaf77">&#9670;&nbsp;</a></span>gotoMeasurement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::gotoMeasurement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place all sensors connected through a serial port into Measurement Mode. </p>
<p>The function places the sensors in measurement mode in the appropriate order as they are sorted by sortBySync. </p>

</div>
</div>
<a id="a46434cd6ee141eb144585a102365c10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46434cd6ee141eb144585a102365c10e">&#9670;&nbsp;</a></span>isDeviceDocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::isDeviceDocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is docked. </p>
<p>Only wireless devices can be regarded as docked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is docked, false otherwise </dd></dl>

</div>
</div>
<a id="a8bcac2b13afa8c57370b4f1b3971a9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcac2b13afa8c57370b4f1b3971a9ce">&#9670;&nbsp;</a></span>isDeviceWireless()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::isDeviceWireless </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected. </p>
<p>If the device ID is not found, the function returns false and the lastResult value is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is wirelessly connected, false otherwise </dd></dl>

</div>
</div>
<a id="a8ce26299dc35a9bd4ee6941da2e59cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce26299dc35a9bd4ee6941da2e59cdb">&#9670;&nbsp;</a></span>lastHardwareError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::lastHardwareError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last hardware error code. </p>
<dl class="section return"><dt>Returns</dt><dd>The last hardware error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">resultText()</a> </dd></dl>

</div>
</div>
<a id="aabfee86128bea857fb2d2f4a960ca20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfee86128bea857fb2d2f4a960ca20f">&#9670;&nbsp;</a></span>lastHardwareErrorDeviceId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsControl::lastHardwareErrorDeviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device ID that caused the last hardware error. </dd></dl>

</div>
</div>
<a id="a2e3979db861a602e5455ce7c8357f427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3979db861a602e5455ce7c8357f427">&#9670;&nbsp;</a></span>lastResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::lastResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result value of the last operation. </p>
<p>The result values are codes that describe a failure in more detail. </p><dl class="section return"><dt>Returns</dt><dd>the last known error code </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#aa14cbf23892c0df0a10bdacdd99d7cf2" title="Get the accompanying error text for the value returned by lastResult()">lastResultText()</a> </dd></dl>

</div>
</div>
<a id="aa14cbf23892c0df0a10bdacdd99d7cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14cbf23892c0df0a10bdacdd99d7cf2">&#9670;&nbsp;</a></span>lastResultText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsControl::lastResultText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the accompanying error text for the value returned by <a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a> </p>
<p>This is more than a convenience function for </p><div class="fragment"><div class="line"><a class="code" href="struct_xs_string.html">XsString</a> <a class="code" href="struct_xs_control.html#aa14cbf23892c0df0a10bdacdd99d7cf2">lastResultText</a> = <a class="code" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272">XsControl::resultText</a>(xscontrol-&gt;lastResult());</div>
</div><!-- fragment --><p> It may provide situation-specific information instead. </p><dl class="section return"><dt>Returns</dt><dd>a human readable error description </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>

</div>
</div>
<a id="a700e2ba28d2710417b2e321520597a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700e2ba28d2710417b2e321520597a14">&#9670;&nbsp;</a></span>loadFilterProfiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::loadFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load filter profile definitions from a settings file with the given <em>filename</em>. </p>
<p>To use the filtering properly, XDA requires filter settings usually stored in a scenarios.xsb file. XSB is the Xsens Settings Binary format. This function allows you to specify the full path + filename to use instead of the default filter profiles embedded in the dll.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full path+filename to use for loading the parameters. When empty, the default filter profiles are loaded. On Linux this is "./scenarios.xsb", on Windows it is read from the dll resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a id="a14babb4414bb25989f3224c7a300fc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14babb4414bb25989f3224c7a300fc24">&#9670;&nbsp;</a></span>mainDeviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::mainDeviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of main devices. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of main devices </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a323c0d96891d19f492662b217ff37ed6" title="Get the device IDs of the available main devices.">mainDeviceIds()</a>, mainDeviceId(const XsDeviceId&amp;) </dd></dl>

</div>
</div>
<a id="a323c0d96891d19f492662b217ff37ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323c0d96891d19f492662b217ff37ed6">&#9670;&nbsp;</a></span>mainDeviceIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::mainDeviceIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device IDs of the available main devices. </p>
<p>Main devices are the devices communicating with the serial port, typically Bodypacks, Awinda Stations and stand-alone MTis or MTxs. </p><dl class="section return"><dt>Returns</dt><dd>a std::vector with the device IDs. </dd></dl>

</div>
</div>
<a id="a7854a2f373f4d8af61fb4f05da336b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7854a2f373f4d8af61fb4f05da336b2b">&#9670;&nbsp;</a></span>mainDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> XsControl::mainDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface objects. </p>
<dl class="section return"><dt>Returns</dt><dd>A list containing pointers to the main device <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> objects </dd></dl>

</div>
</div>
<a id="a2b7afbf81e317983c6bfec40e1837048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7afbf81e317983c6bfec40e1837048">&#9670;&nbsp;</a></span>mtCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::mtCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of connected MTs. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of MTs, including both main and child devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a91c40ef1b937926ef8178f173cab4f84" title="Get the device IDs of the available MTs.">mtDeviceIds()</a> </dd></dl>

</div>
</div>
<a id="a91c40ef1b937926ef8178f173cab4f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c40ef1b937926ef8178f173cab4f84">&#9670;&nbsp;</a></span>mtDeviceIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::mtDeviceIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of the available MTs. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector with the device IDs. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a2b7afbf81e317983c6bfec40e1837048" title="Get the number of connected MTs.">mtCount</a> </dd></dl>

</div>
</div>
<a id="a6076a44725ba5f8bbe31fdcd4865585d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6076a44725ba5f8bbe31fdcd4865585d">&#9670;&nbsp;</a></span>openCustomPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openCustomPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channelLatency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>User-provided identifier for the custom channel. Supplying the same channel Id more than once gives a XV_ALREADYOPEN result (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>getLastResult) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelLatency</td><td>The worst-case round-trip delay in milliseconds induced by the custom channel. XDA will add this latency to its communication timeout values </td></tr>
    <tr><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port was successfully opened. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a90cfd08f3e7c65b057062bcbed1f425b" title="Closes a custom communication channel.">closeCustomPort</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a4bb8fa1b3dbed12399023cc1defb1066" title="Feed data coming back from an Xsens device over a custom channel into XDA.">transmissionReceived</a> </dd></dl>

</div>
</div>
<a id="a8016cd90e619844c9e70cffb9fca6a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8016cd90e619844c9e70cffb9fca6a0b">&#9670;&nbsp;</a></span>openImarPort_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openImarPort_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imarType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a communication channel on serial port with the given <em>portname</em>. </p>
<p>If opening the port is successful, the connected devices are available through the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> interface.</p>
<p>The expected value for <em>portname</em> on Microsoft Windows platforms is "COMx" where x is the port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramname">portname</td><td>The name of the port. </td></tr>
    <tr><td class="paramname">imarType</td><td>The type of iMAR device that is used </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>openPort(int, XsBaudRate, bool) </dd></dl>

</div>
</div>
<a id="ae19d4bbf1c8331a77c1583800314fb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19d4bbf1c8331a77c1583800314fb60">&#9670;&nbsp;</a></span>openLogFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the log file with the given <em>filename</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>True is the file was opened successfully. False if an error was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the file to open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a>, loadLogFile(), logFileName() </dd></dl>

</div>
</div>
<a id="a0dcd5f3427b7509b07baf64650e56dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcd5f3427b7509b07baf64650e56dbd">&#9670;&nbsp;</a></span>openPort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a communication channel on serial port with the given <em>portname</em>. </p>
<p>If opening the port is successful, the connected devices are available through the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> interface.</p>
<p>The expected value for <em>portname</em> on Microsoft Windows platforms is "COMx" where x is the port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">portname</td><td>The name of the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#ace2f1637761664f1828e4d7895cdb453" title="Open a communication channel to the given COM portNr.">openPort(int, XsBaudRate, uint32_t, bool)</a> </dd></dl>

</div>
</div>
<a id="ace2f1637761664f1828e4d7895cdb453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2f1637761664f1828e4d7895cdb453">&#9670;&nbsp;</a></span>openPort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a communication channel to the given COM <em>portNr</em>. </p>
<p>This is a convenience overload for openPort(const XsString&amp;, XsBaudRate, bool). This function is available on Microsoft Windows only due to the ambiguous nature of port numbers on other platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">portNr</td><td>The port number. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port was opened successfully, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd" title="Open a communication channel on serial port with the given portname.">openPort(const XsString&amp;, XsBaudRate, uint32_t, bool)</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a2e3979db861a602e5455ce7c8357f427" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>

</div>
</div>
<a id="a5bef49e962f8f86f5fecd909958c4718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bef49e962f8f86f5fecd909958c4718">&#9670;&nbsp;</a></span>openPort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a communication channel using the details in the supplied XsPortInfo structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">portinfo</td><td>Contains the details of the port to open. The <em>portinfo</em> may be updated with a detected deviceid </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices. Only necessary if <em>portInfo</em> does not contain a device ID of an RS485 device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd>openPort(const XsString &amp;, XsBaudRate, uint32_t) </dd></dl>

</div>
</div>
<a id="acad344df7bb853909b6e240adb7a0d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad344df7bb853909b6e240adb7a0d38">&#9670;&nbsp;</a></span>openPortWithCredentials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPortWithCredentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a communication channel using the details in the supplied XsPortInfo structure using the supplied credentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>Contains the details of the connection to open. The device ID in the structure may be updated by this function. </td></tr>
    <tr><td class="paramname">id</td><td>The user ID to be supplied for the authentication </td></tr>
    <tr><td class="paramname">key</td><td>The key to be supplied for the authentication </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd>openPort(const XsPortInfo &amp;, uint32_t, bool) </dd>
<dd>
openPort(const XsString &amp;, XsBaudRate, uint32_t) </dd></dl>

</div>
</div>
<a id="a8b49db27bd202e7b2f5d24468ec34bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b49db27bd202e7b2f5d24468ec34bd1">&#9670;&nbsp;</a></span>removeCallbackHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a handler from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>

</div>
</div>
<a id="aabb67a6378974b510f906759a4dc2e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb67a6378974b510f906759a4dc2e8d">&#9670;&nbsp;</a></span>removeExistingDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::removeExistingDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> const &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close an existing device. Because it was detected somewhere else. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the device ID to look for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee6e97e9dad8eea2681994d9d31cd272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6e97e9dad8eea2681994d9d31cd272">&#9670;&nbsp;</a></span>resultText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsControl::resultText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>resultCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a descriptive text for the given <em>resultCode</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultCode</td><td>The result code to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>resultCode</em> translated into an XsString </dd></dl>

</div>
</div>
<a id="a3fcb04c842fdab3f1cd880e26c673e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcb04c842fdab3f1cd880e26c673e77">&#9670;&nbsp;</a></span>setInitialPositionLLA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::setInitialPositionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lla</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current GNSS position of the system. </p>
<p>This function will update the Latitude, Longitude and Altitude of the system and all connected devices. This differs from <a class="el" href="struct_xs_control.html#a0b1f958d74b3969deb4f82cb888648f1" title="Returns the broadcast device.">broadcast()</a>-&gt;<a class="el" href="struct_xs_control.html#a3fcb04c842fdab3f1cd880e26c673e77" title="Sets the current GNSS position of the system.">setInitialPositionLLA()</a> in that the setting is persistent for the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> and will be applied to devices connected after the setting has been made. Note: this XDA data type is the setting initialPositionLLA, which is set by setInitialPositionLLA. It's value is therefore static. Use LatitudeLongitude to retrieve the live position data from the MTi. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>A vector containing the desired Latitude, Longitude and Altitude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true since the function always succeeds, the boolean return value is for consistency in the interface. </dd></dl>

</div>
</div>
<a id="a161b1aab842c36ac535ef814a3883ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161b1aab842c36ac535ef814a3883ec8">&#9670;&nbsp;</a></span>setOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>disable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peristently enable or disable options. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data and what data-retention policy to use. On a system with limited resources it may be useful to limit the processing and data retention done by XDA. By default XDA will do all processing it can do, but retain as little data as possible. This function remembers the setting and applies it to new devices when they are created as well as broadcasting it to existing devices. In case of conflict, <em>enable</em> supersedes <em>disable</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>A logically OR'ed combination of XsOptions to enable </td></tr>
    <tr><td class="paramname">disable</td><td>A logically OR'ed combination of XsOptions to disable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>While <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> uses these options in an additional manner, remembering whatever was enabled/disabled before, calling the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> version replaces all its remembered enable/disable values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a4347410af4204ad77de2f1eafba8b529" title="Peristently enable or disable options.">setOptionsForce</a> </dd></dl>

</div>
</div>
<a id="a4347410af4204ad77de2f1eafba8b529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4347410af4204ad77de2f1eafba8b529">&#9670;&nbsp;</a></span>setOptionsForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setOptionsForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peristently enable or disable options. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data and what data-retention policy to use. On a system with limited resources it may be useful to limit the processing and data retention done by XDA. By default XDA will do all processing it can do, but retain as little data as possible. This function remembers the setting and applies it to new devices when they are created as well as broadcasting it to existing devices. Any non-enabled options are explicitly disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>A logically OR'ed combination of the desired enabled XsOptions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Contrary to <em>setOptions</em> this function will do a hard override of all options of the child devices as it will assume that any non-enabled option should be specifically disabled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8" title="Peristently enable or disable options.">setOptions</a> </dd></dl>

</div>
</div>
<a id="aba342544f9f4d7d6a64a0742b45f401a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba342544f9f4d7d6a64a0742b45f401a">&#9670;&nbsp;</a></span>setPersistentSettings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setPersistentSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the persistent settings to a (newly created) device. </p>
<p>These settings include whether to perform filtering, explicit initialPositionLLA values, etc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to write the settings to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1622bed2a39870357796a242e40b92d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1622bed2a39870357796a242e40b92d5">&#9670;&nbsp;</a></span>startRestoreCommunication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::startRestoreCommunication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts restore communication procedure. </p>
<p>Restores the communication settings to the default factory settings. </p><dl class="section note"><dt>Note</dt><dd>Works with RS422 and legacy products only. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portName</td><td>the name of port to which device is connected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if restore communication procedure was successful. </dd></dl>

</div>
</div>
<a id="a4bb8fa1b3dbed12399023cc1defb1066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb8fa1b3dbed12399023cc1defb1066">&#9670;&nbsp;</a></span>transmissionReceived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::transmissionReceived </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feed data coming back from an Xsens device over a custom channel into XDA. </p>
<dl class="section note"><dt>Note</dt><dd>For correct operation of XDA it is key that the transmissionReceived function is called from a separate thread </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user-provided identifier of the custom channel </td></tr>
    <tr><td class="paramname">data</td><td>The data to feed back into XDA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astruct_xs_control_html_aa14cbf23892c0df0a10bdacdd99d7cf2"><div class="ttname"><a href="struct_xs_control.html#aa14cbf23892c0df0a10bdacdd99d7cf2">XsControl::lastResultText</a></div><div class="ttdeci">XsString lastResultText() const</div><div class="ttdoc">Get the accompanying error text for the value returned by lastResult()</div><div class="ttdef"><b>Definition:</b> xscontrol_def.cpp:359</div></div>
<div class="ttc" id="astruct_xs_control_html_aee6e97e9dad8eea2681994d9d31cd272"><div class="ttname"><a href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272">XsControl::resultText</a></div><div class="ttdeci">static XsString resultText(XsResultValue resultCode)</div><div class="ttdoc">Get a descriptive text for the given resultCode.</div><div class="ttdef"><b>Definition:</b> xscontrol_def.cpp:122</div></div>
<div class="ttc" id="astruct_xs_string_html"><div class="ttname"><a href="struct_xs_string.html">XsString</a></div><div class="ttdoc">A 0-terminated managed string of characters.</div><div class="ttdef"><b>Definition:</b> xsstring.h:160</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_xs_control.html">XsControl</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
