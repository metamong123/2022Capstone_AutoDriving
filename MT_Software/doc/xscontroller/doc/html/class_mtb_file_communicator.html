<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XsController: MtbFileCommunicator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xsenslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XsController
   &#160;<span id="projectnumber">2021.4.0</span>
   </div>
   <div id="projectbrief">Xsens Device API Public Communication Objects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_mtb_file_communicator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_mtb_file_communicator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MtbFileCommunicator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that is used for the communcation with a mtb file.  
 <a href="class_mtb_file_communicator.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MtbFileCommunicator:</div>
<div class="dyncontent">
<div class="center"><img src="class_mtb_file_communicator__inherit__graph.png" border="0" usemap="#_mtb_file_communicator_inherit__map" alt="Inheritance graph"/></div>
<map name="_mtb_file_communicator_inherit__map" id="_mtb_file_communicator_inherit__map">
<area shape="rect" title="A class that is used for the communcation with a mtb file." alt="" coords="67,304,231,331"/>
<area shape="rect" href="struct_communicator.html" title="A base struct for a communication interface." alt="" coords="25,229,144,256"/>
<area shape="rect" href="class_callback_manager_xda.html" title="Class that delegates callbacks to registered XsCallbackHandlerItems." alt="" coords="5,155,164,181"/>
<area shape="rect" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API." alt="" coords="37,80,132,107"/>
<area shape="rect" href="struct_xs_callback_plain_c.html" title="Structure that contains callback functions for the Xsens Device API." alt="" coords="17,5,152,32"/>
<area shape="rect" href="class_file_loader.html" title="A class that loads file." alt="" coords="169,229,257,256"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abae513861c8502a1126f44cc380ab750"><td class="memItemLeft" align="right" valign="top"><a id="abae513861c8502a1126f44cc380ab750"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#abae513861c8502a1126f44cc380ab750">MtbFileCommunicator</a> ()</td></tr>
<tr class="memdesc:abae513861c8502a1126f44cc380ab750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:abae513861c8502a1126f44cc380ab750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b981acbb7792e315d876866ed1912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa81b981acbb7792e315d876866ed1912">abortLoadLogFile</a> () override</td></tr>
<tr class="memdesc:aa81b981acbb7792e315d876866ed1912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a process that takes a long time to complete.  <a href="class_mtb_file_communicator.html#aa81b981acbb7792e315d876866ed1912">More...</a><br /></td></tr>
<tr class="separator:aa81b981acbb7792e315d876866ed1912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004d7d02ad4007707f78064a658dc930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a004d7d02ad4007707f78064a658dc930">addProtocolHandler</a> (<a class="el" href="class_i_protocol_handler.html">IProtocolHandler</a> *handler) override</td></tr>
<tr class="memdesc:a004d7d02ad4007707f78064a658dc930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the protocol handler.  <a href="class_mtb_file_communicator.html#a004d7d02ad4007707f78064a658dc930">More...</a><br /></td></tr>
<tr class="separator:a004d7d02ad4007707f78064a658dc930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78208205ae08de9eb3c5c6af6ec98ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a78208205ae08de9eb3c5c6af6ec98ae9">closeLogFile</a> () override</td></tr>
<tr class="memdesc:a78208205ae08de9eb3c5c6af6ec98ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the log file.  <a href="class_mtb_file_communicator.html#a78208205ae08de9eb3c5c6af6ec98ae9">More...</a><br /></td></tr>
<tr class="separator:a78208205ae08de9eb3c5c6af6ec98ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8ef7c7ac43ae74e766e47591e79468"><td class="memItemLeft" align="right" valign="top"><a id="aaa8ef7c7ac43ae74e766e47591e79468"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aaa8ef7c7ac43ae74e766e47591e79468">closePort</a> () override</td></tr>
<tr class="memdesc:aaa8ef7c7ac43ae74e766e47591e79468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the open port. <br /></td></tr>
<tr class="separator:aaa8ef7c7ac43ae74e766e47591e79468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282c87d08be4df4711e6d98f57d3027d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a282c87d08be4df4711e6d98f57d3027d">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;msg, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv, uint32_t timeout) override</td></tr>
<tr class="memdesc:a282c87d08be4df4711e6d98f57d3027d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretend to be a live system.  <a href="class_mtb_file_communicator.html#a282c87d08be4df4711e6d98f57d3027d">More...</a><br /></td></tr>
<tr class="separator:a282c87d08be4df4711e6d98f57d3027d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5532cbf527b981ab5001782c422ed7b"><td class="memItemLeft" align="right" valign="top"><a id="ae5532cbf527b981ab5001782c422ed7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ae5532cbf527b981ab5001782c422ed7b">flushPort</a> () override</td></tr>
<tr class="memdesc:ae5532cbf527b981ab5001782c422ed7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all remaining data on the open port. <br /></td></tr>
<tr class="separator:ae5532cbf527b981ab5001782c422ed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfac8c5baf5899efdf13d3ab571d30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aadfac8c5baf5899efdf13d3ab571d30f">getDeviceId</a> () override</td></tr>
<tr class="memdesc:aadfac8c5baf5899efdf13d3ab571d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to get device ID.  <a href="class_mtb_file_communicator.html#aadfac8c5baf5899efdf13d3ab571d30f">More...</a><br /></td></tr>
<tr class="separator:aadfac8c5baf5899efdf13d3ab571d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ce6dc7dfa92438f88c1bee18197f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a49ce6dc7dfa92438f88c1bee18197f12">gotoConfig</a> (bool detectRs485=false) override</td></tr>
<tr class="memdesc:a49ce6dc7dfa92438f88c1bee18197f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to go to config mode.  <a href="class_mtb_file_communicator.html#a49ce6dc7dfa92438f88c1bee18197f12">More...</a><br /></td></tr>
<tr class="separator:a49ce6dc7dfa92438f88c1bee18197f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f59969ccaa52892a8484bb987267e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a345f59969ccaa52892a8484bb987267e">gotoMeasurement</a> () override</td></tr>
<tr class="memdesc:a345f59969ccaa52892a8484bb987267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to go to measurement mode.  <a href="class_mtb_file_communicator.html#a345f59969ccaa52892a8484bb987267e">More...</a><br /></td></tr>
<tr class="separator:a345f59969ccaa52892a8484bb987267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68d55258bda7ded6b97fd244562deb8"><td class="memItemLeft" align="right" valign="top"><a id="aa68d55258bda7ded6b97fd244562deb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa68d55258bda7ded6b97fd244562deb8">isDockedAt</a> (<a class="el" href="struct_communicator.html">Communicator</a> *other) const override</td></tr>
<tr class="memdesc:aa68d55258bda7ded6b97fd244562deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>other</em> device is docked at this device. <br /></td></tr>
<tr class="separator:aa68d55258bda7ded6b97fd244562deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d3ca888b5603ab469bc1f1ac79de6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ad1d3ca888b5603ab469bc1f1ac79de6e">isLoadLogFileInProgress</a> () const override</td></tr>
<tr class="separator:ad1d3ca888b5603ab469bc1f1ac79de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ab4a685db5ae979f0c5d8a711ab06b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a87ab4a685db5ae979f0c5d8a711ab06b">isPortOpen</a> () const override</td></tr>
<tr class="separator:a87ab4a685db5ae979f0c5d8a711ab06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b00cea4663b9472e39499cc9e3b2602"><td class="memItemLeft" align="right" valign="top"><a id="a8b00cea4663b9472e39499cc9e3b2602"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a8b00cea4663b9472e39499cc9e3b2602">isReadingFromFile</a> () const override</td></tr>
<tr class="memdesc:a8b00cea4663b9472e39499cc9e3b2602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether we are reading from file. <br /></td></tr>
<tr class="separator:a8b00cea4663b9472e39499cc9e3b2602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b4b21bcfc147f7cc423c8fa6b06c8"><td class="memItemLeft" align="right" valign="top"><a id="aa78b4b21bcfc147f7cc423c8fa6b06c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa78b4b21bcfc147f7cc423c8fa6b06c8">loadLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *device) override</td></tr>
<tr class="memdesc:aa78b4b21bcfc147f7cc423c8fa6b06c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a log file with thread pool. <br /></td></tr>
<tr class="separator:aa78b4b21bcfc147f7cc423c8fa6b06c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9805bfdb282c86fac2b0303a4a36bbd7"><td class="memItemLeft" align="right" valign="top"><a id="a9805bfdb282c86fac2b0303a4a36bbd7"></a>
<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a9805bfdb282c86fac2b0303a4a36bbd7">logFileDate</a> () const override</td></tr>
<tr class="memdesc:a9805bfdb282c86fac2b0303a4a36bbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the date of the open log file. <br /></td></tr>
<tr class="separator:a9805bfdb282c86fac2b0303a4a36bbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d59ed9a6ad743520cd2707ebeb878"><td class="memItemLeft" align="right" valign="top"><a id="aa36d59ed9a6ad743520cd2707ebeb878"></a>
<a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa36d59ed9a6ad743520cd2707ebeb878">logFileName</a> () const override</td></tr>
<tr class="memdesc:aa36d59ed9a6ad743520cd2707ebeb878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the name of the open log file or an empty string if no log file is open. <br /></td></tr>
<tr class="separator:aa36d59ed9a6ad743520cd2707ebeb878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebdd9ca5ea57f90521be8b1dc1965c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aaebdd9ca5ea57f90521be8b1dc1965c7">logFileReadPosition</a> () const override</td></tr>
<tr class="memdesc:aaebdd9ca5ea57f90521be8b1dc1965c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the read position of the log file.  <a href="class_mtb_file_communicator.html#aaebdd9ca5ea57f90521be8b1dc1965c7">More...</a><br /></td></tr>
<tr class="separator:aaebdd9ca5ea57f90521be8b1dc1965c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425a367a771a94d1e47dcb791bc3b9d2"><td class="memItemLeft" align="right" valign="top"><a id="a425a367a771a94d1e47dcb791bc3b9d2"></a>
<a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a425a367a771a94d1e47dcb791bc3b9d2">logFileSize</a> () const override</td></tr>
<tr class="memdesc:a425a367a771a94d1e47dcb791bc3b9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of the open log file in bytes. <br /></td></tr>
<tr class="separator:a425a367a771a94d1e47dcb791bc3b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c932f470af852f095a7ff41f774234"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a98c932f470af852f095a7ff41f774234">openLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename) override</td></tr>
<tr class="memdesc:a98c932f470af852f095a7ff41f774234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a log file for input.  <a href="class_mtb_file_communicator.html#a98c932f470af852f095a7ff41f774234">More...</a><br /></td></tr>
<tr class="separator:a98c932f470af852f095a7ff41f774234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49568e601aed36f9b2f1ec4da338f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ae49568e601aed36f9b2f1ec4da338f46">openPort</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;<a class="el" href="class_mtb_file_communicator.html#a90baa66d3f9098833531da0b8be26b4a">portInfo</a>, <a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a> stage=OPS_Full, bool detectRs485=false) override</td></tr>
<tr class="memdesc:ae49568e601aed36f9b2f1ec4da338f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a port.  <a href="class_mtb_file_communicator.html#ae49568e601aed36f9b2f1ec4da338f46">More...</a><br /></td></tr>
<tr class="separator:ae49568e601aed36f9b2f1ec4da338f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90baa66d3f9098833531da0b8be26b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a90baa66d3f9098833531da0b8be26b4a">portInfo</a> () const override</td></tr>
<tr class="separator:a90baa66d3f9098833531da0b8be26b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312ba4a98023822449dae795d7ae4a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a312ba4a98023822449dae795d7ae4a72">readMessage</a> (uint8_t msgId=0) override</td></tr>
<tr class="memdesc:a312ba4a98023822449dae795d7ae4a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from the open file.  <a href="class_mtb_file_communicator.html#a312ba4a98023822449dae795d7ae4a72">More...</a><br /></td></tr>
<tr class="separator:a312ba4a98023822449dae795d7ae4a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c86e20a386e73ddce139bb7e312e9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a3c86e20a386e73ddce139bb7e312e9fa">readMessageFromStartOfFile</a> (uint8_t msgId, int maxMsgs=0) override</td></tr>
<tr class="memdesc:a3c86e20a386e73ddce139bb7e312e9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from the start of the open file.  <a href="class_mtb_file_communicator.html#a3c86e20a386e73ddce139bb7e312e9fa">More...</a><br /></td></tr>
<tr class="separator:a3c86e20a386e73ddce139bb7e312e9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8207e51e5e32f36da3c50688b75bf5"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="struct_xs_message.html">XsMessage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a9b8207e51e5e32f36da3c50688b75bf5">readMessagesFromStartOfFile</a> (uint8_t msgId, int maxMsgs=0) override</td></tr>
<tr class="memdesc:a9b8207e51e5e32f36da3c50688b75bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple similar messages from the start of the open file.  <a href="class_mtb_file_communicator.html#a9b8207e51e5e32f36da3c50688b75bf5">More...</a><br /></td></tr>
<tr class="separator:a9b8207e51e5e32f36da3c50688b75bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515b5fc108dd7f5e6ff82ec8ccae08ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a515b5fc108dd7f5e6ff82ec8ccae08ec">reopenPort</a> (<a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a> stage=OPS_Full, bool skipDeviceIdCheck=false) override</td></tr>
<tr class="memdesc:a515b5fc108dd7f5e6ff82ec8ccae08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopens the port.  <a href="class_mtb_file_communicator.html#a515b5fc108dd7f5e6ff82ec8ccae08ec">More...</a><br /></td></tr>
<tr class="separator:a515b5fc108dd7f5e6ff82ec8ccae08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b0202be2b95f6bcc0f5d5bda35d7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a28b0202be2b95f6bcc0f5d5bda35d7d8">resetLogFileReadPosition</a> (void) override</td></tr>
<tr class="memdesc:a28b0202be2b95f6bcc0f5d5bda35d7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart reading from the start of the open log file.  <a href="class_mtb_file_communicator.html#a28b0202be2b95f6bcc0f5d5bda35d7d8">More...</a><br /></td></tr>
<tr class="separator:a28b0202be2b95f6bcc0f5d5bda35d7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1645929c7d07b082781a3d242be48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ace1645929c7d07b082781a3d242be48f">setGotoConfigTimeout</a> (uint32_t timeout) override</td></tr>
<tr class="memdesc:ace1645929c7d07b082781a3d242be48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for the gotoConfig function.  <a href="class_mtb_file_communicator.html#ace1645929c7d07b082781a3d242be48f">More...</a><br /></td></tr>
<tr class="separator:ace1645929c7d07b082781a3d242be48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be6bd7d143b4e1a1f2774cf21385bae"><td class="memItemLeft" align="right" valign="top"><a id="a1be6bd7d143b4e1a1f2774cf21385bae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a1be6bd7d143b4e1a1f2774cf21385bae">setKeepAlive</a> (bool enable) override</td></tr>
<tr class="memdesc:a1be6bd7d143b4e1a1f2774cf21385bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either disable or enable (default) the keep alive mechanism (if supported by the device) <br /></td></tr>
<tr class="separator:a1be6bd7d143b4e1a1f2774cf21385bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449e545f43bff28ba7971288f1f4f924"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a449e545f43bff28ba7971288f1f4f924">writeMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message) override</td></tr>
<tr class="memdesc:a449e545f43bff28ba7971288f1f4f924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message to the device.  <a href="class_mtb_file_communicator.html#a449e545f43bff28ba7971288f1f4f924">More...</a><br /></td></tr>
<tr class="separator:a449e545f43bff28ba7971288f1f4f924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:af732adc9e6e84804da996b715c83c803 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="af732adc9e6e84804da996b715c83c803"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#af732adc9e6e84804da996b715c83c803">Communicator</a> (void)</td></tr>
<tr class="memdesc:af732adc9e6e84804da996b715c83c803 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, creates some management objects and clears the rest by calling initialize() <br /></td></tr>
<tr class="separator:af732adc9e6e84804da996b715c83c803 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7cb30f37dd08db96c76ab3c86e014b inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a5f7cb30f37dd08db96c76ab3c86e014b">addReplyObject</a> (<a class="el" href="class_reply_object.html">ReplyObject</a> *obj)</td></tr>
<tr class="memdesc:a5f7cb30f37dd08db96c76ab3c86e014b inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom <a class="el" href="class_reply_object.html" title="Abstract reply object. Blocks on a semaphore when requesting the message until the message has been s...">ReplyObject</a>.  <a href="struct_communicator.html#a5f7cb30f37dd08db96c76ab3c86e014b">More...</a><br /></td></tr>
<tr class="separator:a5f7cb30f37dd08db96c76ab3c86e014b inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83d20bf72bcfc7df91564159d2a947 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aba83d20bf72bcfc7df91564159d2a947">addReplyObject</a> (uint8_t mid)</td></tr>
<tr class="memdesc:aba83d20bf72bcfc7df91564159d2a947 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="class_mid_reply_object.html" title="Reply object that only checks the message identifier.">MidReplyObject</a>.  <a href="struct_communicator.html#aba83d20bf72bcfc7df91564159d2a947">More...</a><br /></td></tr>
<tr class="separator:aba83d20bf72bcfc7df91564159d2a947 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331d3bc7f8845fd6d8b62a64dde8f9a5 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a331d3bc7f8845fd6d8b62a64dde8f9a5">addReplyObject</a> (uint8_t mid, XsSize offset, XsSize size, uint8_t const *data)</td></tr>
<tr class="memdesc:a331d3bc7f8845fd6d8b62a64dde8f9a5 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="class_mid_and_data_reply_object.html" title="Reply object that checks the message identifier and data in the data field.">MidAndDataReplyObject</a>.  <a href="struct_communicator.html#a331d3bc7f8845fd6d8b62a64dde8f9a5">More...</a><br /></td></tr>
<tr class="separator:a331d3bc7f8845fd6d8b62a64dde8f9a5 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e4963e852857d8e919978b5384ea3b inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a44e4963e852857d8e919978b5384ea3b">allowReprocessing</a> () const</td></tr>
<tr class="separator:a44e4963e852857d8e919978b5384ea3b inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c99be8ee160af0e79888622b9bd44b inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#af4c99be8ee160af0e79888622b9bd44b">childDeviceCount</a> () const</td></tr>
<tr class="separator:af4c99be8ee160af0e79888622b9bd44b inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c7d171bbc01a004f50b414621cb7e8 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a20c7d171bbc01a004f50b414621cb7e8">defaultTimeout</a> () const</td></tr>
<tr class="separator:a20c7d171bbc01a004f50b414621cb7e8 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d72b1fa5445ee561db946408dfc924f inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a0d72b1fa5445ee561db946408dfc924f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a0d72b1fa5445ee561db946408dfc924f">destroy</a> ()</td></tr>
<tr class="memdesc:a0d72b1fa5445ee561db946408dfc924f inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the communicator. <br /></td></tr>
<tr class="separator:a0d72b1fa5445ee561db946408dfc924f inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adcf4eecb610758e57efeddd79e100f inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a9adcf4eecb610758e57efeddd79e100f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a9adcf4eecb610758e57efeddd79e100f">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a9adcf4eecb610758e57efeddd79e100f inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a9adcf4eecb610758e57efeddd79e100f inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cb436aa72f757dfec1968cb50d69dc inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a54cb436aa72f757dfec1968cb50d69dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a54cb436aa72f757dfec1968cb50d69dc">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message, uint32_t timeout)</td></tr>
<tr class="memdesc:a54cb436aa72f757dfec1968cb50d69dc inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a54cb436aa72f757dfec1968cb50d69dc inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea360b8a63d1f9325b9ff01fffd0d8 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a49ea360b8a63d1f9325b9ff01fffd0d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a49ea360b8a63d1f9325b9ff01fffd0d8">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv)</td></tr>
<tr class="memdesc:a49ea360b8a63d1f9325b9ff01fffd0d8 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a49ea360b8a63d1f9325b9ff01fffd0d8 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148c456f7ef9c9c2fb8c7ef4ee259e35 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a148c456f7ef9c9c2fb8c7ef4ee259e35"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a148c456f7ef9c9c2fb8c7ef4ee259e35">handleMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a148c456f7ef9c9c2fb8c7ef4ee259e35 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a <em>message</em>. <br /></td></tr>
<tr class="separator:a148c456f7ef9c9c2fb8c7ef4ee259e35 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f838f1f5da8b3ec5cba61a47d6ee2a inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a89f838f1f5da8b3ec5cba61a47d6ee2a">hasProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type) const</td></tr>
<tr class="separator:a89f838f1f5da8b3ec5cba61a47d6ee2a inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b1f15cfc16c51f839f0fc5f57060a6 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">lastResult</a> () const</td></tr>
<tr class="memdesc:a01b1f15cfc16c51f839f0fc5f57060a6 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">More...</a><br /></td></tr>
<tr class="separator:a01b1f15cfc16c51f839f0fc5f57060a6 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace27546fc55e56bc861e1c29bf7955a7 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ace27546fc55e56bc861e1c29bf7955a7">lastResultText</a> () const</td></tr>
<tr class="memdesc:ace27546fc55e56bc861e1c29bf7955a7 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accompanying error text for the value returned by <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6" title="Get the result value of the last operation.">lastResult()</a> It may provide situation-specific information instead.  <a href="struct_communicator.html#ace27546fc55e56bc861e1c29bf7955a7">More...</a><br /></td></tr>
<tr class="separator:ace27546fc55e56bc861e1c29bf7955a7 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c63e78f350c54778c4fd31924ac92 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a849c63e78f350c54778c4fd31924ac92">masterDeviceId</a> () const</td></tr>
<tr class="separator:a849c63e78f350c54778c4fd31924ac92 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef923814a0a92a47cd747f688fd5aac inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7ef923814a0a92a47cd747f688fd5aac">removeProtocolHandler</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type)</td></tr>
<tr class="memdesc:a7ef923814a0a92a47cd747f688fd5aac inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a protocol handler.  <a href="struct_communicator.html#a7ef923814a0a92a47cd747f688fd5aac">More...</a><br /></td></tr>
<tr class="separator:a7ef923814a0a92a47cd747f688fd5aac inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0efda63671e15cc3f4b8862d8827610 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab0efda63671e15cc3f4b8862d8827610">sanityCheck</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const &amp;msg) const</td></tr>
<tr class="memdesc:ab0efda63671e15cc3f4b8862d8827610 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a sanity check on a potential message.  <a href="struct_communicator.html#ab0efda63671e15cc3f4b8862d8827610">More...</a><br /></td></tr>
<tr class="separator:ab0efda63671e15cc3f4b8862d8827610 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e07bb6858d2e4a83ccfc7591b1795 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a319e07bb6858d2e4a83ccfc7591b1795"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a319e07bb6858d2e4a83ccfc7591b1795">scheduleClosePort</a> ()</td></tr>
<tr class="memdesc:a319e07bb6858d2e4a83ccfc7591b1795 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules to close the open port. <br /></td></tr>
<tr class="separator:a319e07bb6858d2e4a83ccfc7591b1795 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aebec75db10bb2ddf1e8d677b3adcd inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a96aebec75db10bb2ddf1e8d677b3adcd">setCredentials</a> (<a class="el" href="struct_xs_string.html">XsString</a> const &amp;id, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;key)</td></tr>
<tr class="memdesc:a96aebec75db10bb2ddf1e8d677b3adcd inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the credentials required for using the device.  <a href="struct_communicator.html#a96aebec75db10bb2ddf1e8d677b3adcd">More...</a><br /></td></tr>
<tr class="separator:a96aebec75db10bb2ddf1e8d677b3adcd inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8a600fa59679e03debe2e6825a2bc4 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a7e8a600fa59679e03debe2e6825a2bc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7e8a600fa59679e03debe2e6825a2bc4">setDefaultTimeout</a> (uint32_t timeout)</td></tr>
<tr class="memdesc:a7e8a600fa59679e03debe2e6825a2bc4 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a default <em>timeout</em>. <br /></td></tr>
<tr class="separator:a7e8a600fa59679e03debe2e6825a2bc4 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb314734f6189e93ff0efad49d76af0 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#adbb314734f6189e93ff0efad49d76af0">setMasterDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *<a class="el" href="struct_communicator.html#a4aa971b033b69bf5c79d800fee6e8723">masterDevice</a>)</td></tr>
<tr class="memdesc:adbb314734f6189e93ff0efad49d76af0 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a master device.  <a href="struct_communicator.html#adbb314734f6189e93ff0efad49d76af0">More...</a><br /></td></tr>
<tr class="separator:adbb314734f6189e93ff0efad49d76af0 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_callback_manager_xda"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_callback_manager_xda')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a></td></tr>
<tr class="memitem:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ae286810bd0b4d20678987b354fa13d29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ae286810bd0b4d20678987b354fa13d29">CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initializes the callback list. <br /></td></tr>
<tr class="separator:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5910d161433653494a59986643233cf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5910d161433653494a59986643233cf6">~CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, clears the callback list. <br /></td></tr>
<tr class="separator:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler to the list.  <a href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">More...</a><br /></td></tr>
<tr class="separator:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">addChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a chained manager to the list.  <a href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">More...</a><br /></td></tr>
<tr class="separator:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback list.  <a href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">More...</a><br /></td></tr>
<tr class="separator:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="acb7c60244a13f84ca7cc06efa50d9685"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acb7c60244a13f84ca7cc06efa50d9685">clearChainedManagers</a> ()</td></tr>
<tr class="memdesc:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the chained manager list. <br /></td></tr>
<tr class="separator:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">copyCallbackHandlersFrom</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from <em>cm</em> into this manager.  <a href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">More...</a><br /></td></tr>
<tr class="separator:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">copyCallbackHandlersTo</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from this manager into <em>cm</em>.  <a href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">More...</a><br /></td></tr>
<tr class="separator:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af2827956387a56712723e9200882179c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2827956387a56712723e9200882179c">onAllBufferedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5f103ff688afdeef381eedd6100331d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5f103ff688afdeef381eedd6100331d2">onAllDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5e64d70ce299958605b6149049e045ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5e64d70ce299958605b6149049e045ef">onAllLiveDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95" title="Called when new data has been received for devices connected to the same main device....">XsCallback::onAllLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a4c0aa7e3be74595cef490b98d1520d1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a4c0aa7e3be74595cef490b98d1520d1e">onAllRecordedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6" title="Called when new data has been received for devices connected to the same main device in a recording s...">XsCallback::onAllRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ad4c8eb08edd64025b3e9405415b38834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad4c8eb08edd64025b3e9405415b38834">onBufferedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399" title="Called when XDA has a data packet that could be written to a log file.">XsCallback::onBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a312575546ab44f788dd3961477ba0e7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a312575546ab44f788dd3961477ba0e7f">onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState) override</td></tr>
<tr class="memdesc:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40" title="Called when XDA has detected a change in the connectivity state of a device.">XsCallback::onConnectivityChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="acc815adc25af17f24207573afa9c94da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acc815adc25af17f24207573afa9c94da">onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a7738059783802ad5e1278108a467ccc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7738059783802ad5e1278108a467ccc2">onDataUnavailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId) override</td></tr>
<tr class="memdesc:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga89d308afd509c0325b4cdb622fd9e645" title="Called when XDA detects that data is forever unavailable.">XsCallback::onDataUnavailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a1409c965b88efc664a2ef7d36e5490f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a1409c965b88efc664a2ef7d36e5490f4">onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState) override</td></tr>
<tr class="memdesc:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0" title="Called when a device&#39;s state has changed (ie config mode, measurement mode, recording mode)">XsCallback::onDeviceStateChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a3a65ae9866cb7a9e8ab11dcfeca1572f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a3a65ae9866cb7a9e8ab11dcfeca1572f">onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error) override</td></tr>
<tr class="memdesc:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onError() callback forwarding function. <br /></td></tr>
<tr class="separator:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a01afaba0ea9f47b5c4f490ee7dba7364"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364">onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request) override</td></tr>
<tr class="memdesc:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5" title="Called when an information request has resulted in a response.">XsCallback::onInfoResponse()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="aebd995bd1dc83e69822f874eabb0c4fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aebd995bd1dc83e69822f874eabb0c4fa">onLiveDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet) override</td></tr>
<tr class="memdesc:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af81b39fa94f8086d9682df2e53ea5e1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af81b39fa94f8086d9682df2e53ea5e1e">onMessageDetected</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage) override</td></tr>
<tr class="memdesc:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a760e93d7f7142fd22c7e134c4cea5f72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a760e93d7f7142fd22c7e134c4cea5f72">onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a73ec10bd8e7cf2df6b4136ad0ac9701e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a73ec10bd8e7cf2df6b4136ad0ac9701e">onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageSentToDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a79ae15c19c791af165c842441993660c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a79ae15c19c791af165c842441993660c">onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last) override</td></tr>
<tr class="memdesc:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e" title="Called when XDA detects that packets have been missed.">XsCallback::onMissedPackets()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="afdeff1e1697266d82f232642aef0cae9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#afdeff1e1697266d82f232642aef0cae9">onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onNonDataMessage() callback forwarding function. <br /></td></tr>
<tr class="separator:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a840ce749572d8997e33ee8f860db97c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a840ce749572d8997e33ee8f860db97c7">onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier) override</td></tr>
<tr class="memdesc:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59" title="Called when a long-duration operation has made some progress or has completed. Examples include loadL...">XsCallback::onProgressUpdated()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a5b6beccc0e4760b652b7be01e859e465"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5b6beccc0e4760b652b7be01e859e465">onRecordedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14" title="Called when new data has been received from a device in a recording state or read from a file....">XsCallback::onRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="af91bb23b63beb62d085182044abb30a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af91bb23b63beb62d085182044abb30a7">onRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result) override</td></tr>
<tr class="memdesc:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onRestoreCommunication callback forwarding function. <br /></td></tr>
<tr class="separator:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">onTransmissionRequest</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data) override</td></tr>
<tr class="memdesc:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">More...</a><br /></td></tr>
<tr class="separator:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="a7471f499ee52bb189ef4e3917a20e5d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7471f499ee52bb189ef4e3917a20e5d0">onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev) override</td></tr>
<tr class="memdesc:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a" title="Called when a wakeup message has been received from a device. This indicates that the device has just...">XsCallback::onWakeupReceived()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a id="ad510877b529df7a85fbc5d601c2fad76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad510877b529df7a85fbc5d601c2fad76">onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message) override</td></tr>
<tr class="memdesc:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290" title="Called when XDA has a message that could be written to a log file.">XsCallback::onWriteMessageToLogFile()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">More...</a><br /></td></tr>
<tr class="separator:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">removeChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove achained manager from the list.  <a href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">More...</a><br /></td></tr>
<tr class="separator:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_xs_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_xs_callback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_xs_callback.html">XsCallback</a></td></tr>
<tr class="memitem:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top"><a id="a491695016a32d02a31e2f4bda826ef47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a491695016a32d02a31e2f4bda826ef47">XsCallback</a> ()</td></tr>
<tr class="memdesc:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">~XsCallback</a> ()</td></tr>
<tr class="memdesc:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">More...</a><br /></td></tr>
<tr class="separator:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af99a77f54a94cdbee6f8257cb339351d"><td class="memItemLeft" align="right" valign="top"><a id="af99a77f54a94cdbee6f8257cb339351d"></a>
static <a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#af99a77f54a94cdbee6f8257cb339351d">construct</a> ()</td></tr>
<tr class="memdesc:af99a77f54a94cdbee6f8257cb339351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new <a class="el" href="class_mtb_file_communicator.html" title="A class that is used for the communcation with a mtb file.">MtbFileCommunicator</a>. <br /></td></tr>
<tr class="separator:af99a77f54a94cdbee6f8257cb339351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:ab6fad6bfc470a21b9165d3ed1825bc29 inherit pub_static_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab6fad6bfc470a21b9165d3ed1825bc29">configurationMessageSearchLimit</a> ()</td></tr>
<tr class="separator:ab6fad6bfc470a21b9165d3ed1825bc29 inherit pub_static_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="memTemplParams" colspan="2"><a id="adf315317a87ae6b114b152c1685b9ea5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#adf315317a87ae6b114b152c1685b9ea5">createUniquePtr</a> ()</td></tr>
<tr class="memdesc:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="struct_communicator.html" title="A base struct for a communication interface.">Communicator</a> of type T and returns it as a UniquePtr&lt;T&gt; <br /></td></tr>
<tr class="separator:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="memTemplParams" colspan="2"><a id="ac6a25ccfb89ac0b8c3d556b27ef33dcc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ac6a25ccfb89ac0b8c3d556b27ef33dcc">createUniquePtr</a> (T *communicator)</td></tr>
<tr class="memdesc:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a UniquePtr&lt;T&gt; from a Communicator*. <br /></td></tr>
<tr class="separator:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a86a9b2b8618b0791a6fb14f581d9a552"><td class="memItemLeft" align="right" valign="top"><a id="a86a9b2b8618b0791a6fb14f581d9a552"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a86a9b2b8618b0791a6fb14f581d9a552">MtbFileCommunicator</a> (std::shared_ptr&lt; <a class="el" href="class_io_interface_file.html">IoInterfaceFile</a> &gt; const &amp;ioInterfaceFile)</td></tr>
<tr class="memdesc:a86a9b2b8618b0791a6fb14f581d9a552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that uses <em>ioInterfaceFile</em>. <br /></td></tr>
<tr class="separator:a86a9b2b8618b0791a6fb14f581d9a552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d80fc4d26de6b4d9c3f99b7e340f65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a03d80fc4d26de6b4d9c3f99b7e340f65">~MtbFileCommunicator</a> ()</td></tr>
<tr class="separator:a03d80fc4d26de6b4d9c3f99b7e340f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ff0da1fa71175cd2ca5bd0c60a9cfa"><td class="memItemLeft" align="right" valign="top"><a id="a46ff0da1fa71175cd2ca5bd0c60a9cfa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a46ff0da1fa71175cd2ca5bd0c60a9cfa">prepareForDestruction</a> () override</td></tr>
<tr class="memdesc:a46ff0da1fa71175cd2ca5bd0c60a9cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares for the destruction. <br /></td></tr>
<tr class="separator:a46ff0da1fa71175cd2ca5bd0c60a9cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f7c132f9cd8608723628afa6ccb152"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a61f7c132f9cd8608723628afa6ccb152">readLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *device) override</td></tr>
<tr class="memdesc:a61f7c132f9cd8608723628afa6ccb152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a log file into cache.  <a href="class_mtb_file_communicator.html#a61f7c132f9cd8608723628afa6ccb152">More...</a><br /></td></tr>
<tr class="separator:a61f7c132f9cd8608723628afa6ccb152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81507126b264871d0a5538ad4c9a9865"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a81507126b264871d0a5538ad4c9a9865">readNextMessage</a> ()</td></tr>
<tr class="memdesc:a81507126b264871d0a5538ad4c9a9865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next message from the open file.  <a href="class_mtb_file_communicator.html#a81507126b264871d0a5538ad4c9a9865">More...</a><br /></td></tr>
<tr class="separator:a81507126b264871d0a5538ad4c9a9865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cb1ea7f701b999619906a9d15978ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a23cb1ea7f701b999619906a9d15978ec">readSinglePacketFromFile</a> () override</td></tr>
<tr class="memdesc:a23cb1ea7f701b999619906a9d15978ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> from an open log file.  <a href="class_mtb_file_communicator.html#a23cb1ea7f701b999619906a9d15978ec">More...</a><br /></td></tr>
<tr class="separator:a23cb1ea7f701b999619906a9d15978ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63788ee066d43dc26c275d4440ea4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ab63788ee066d43dc26c275d4440ea4d3">waitForLastTaskCompletion</a> () override</td></tr>
<tr class="memdesc:ab63788ee066d43dc26c275d4440ea4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the last processing task to complete in the threadpool.  <a href="class_mtb_file_communicator.html#ab63788ee066d43dc26c275d4440ea4d3">More...</a><br /></td></tr>
<tr class="separator:ab63788ee066d43dc26c275d4440ea4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:a4ced5362bf7438924f8d7f1b0c5ec391 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a4ced5362bf7438924f8d7f1b0c5ec391"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4ced5362bf7438924f8d7f1b0c5ec391">~Communicator</a> ()</td></tr>
<tr class="memdesc:a4ced5362bf7438924f8d7f1b0c5ec391 inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, waits for the last scheduled task to complete and then cleans up the object by calling clear() <br /></td></tr>
<tr class="separator:a4ced5362bf7438924f8d7f1b0c5ec391 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa971b033b69bf5c79d800fee6e8723 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4aa971b033b69bf5c79d800fee6e8723">masterDevice</a> () const</td></tr>
<tr class="separator:a4aa971b033b69bf5c79d800fee6e8723 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72c82f6987d62565f8107e1ba93cfa6 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_protocol_manager.html">ProtocolManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ae72c82f6987d62565f8107e1ba93cfa6">protocolManager</a> () const</td></tr>
<tr class="separator:ae72c82f6987d62565f8107e1ba93cfa6 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec58651d63e9b69d54b2a77eff784d inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ad3ec58651d63e9b69d54b2a77eff784d">setAndReturnLastResult</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">lastResult</a>, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;text=<a class="el" href="struct_xs_string.html">XsString</a>()) const</td></tr>
<tr class="memdesc:ad3ec58651d63e9b69d54b2a77eff784d inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last result and returns it.  <a href="struct_communicator.html#ad3ec58651d63e9b69d54b2a77eff784d">More...</a><br /></td></tr>
<tr class="separator:ad3ec58651d63e9b69d54b2a77eff784d inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37b0ef25e91141a622aff2be6c2cd7 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a2f37b0ef25e91141a622aff2be6c2cd7">setLastResult</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> <a class="el" href="struct_communicator.html#a01b1f15cfc16c51f839f0fc5f57060a6">lastResult</a>, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;text=<a class="el" href="struct_xs_string.html">XsString</a>()) const</td></tr>
<tr class="memdesc:a2f37b0ef25e91141a622aff2be6c2cd7 inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last result.  <a href="struct_communicator.html#a2f37b0ef25e91141a622aff2be6c2cd7">More...</a><br /></td></tr>
<tr class="separator:a2f37b0ef25e91141a622aff2be6c2cd7 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba6a5ee540ee88b2a7c8d7a92ab4bad inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aeba6a5ee540ee88b2a7c8d7a92ab4bad">setMasterDeviceId</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId)</td></tr>
<tr class="memdesc:aeba6a5ee540ee88b2a7c8d7a92ab4bad inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a master device ID.  <a href="struct_communicator.html#aeba6a5ee540ee88b2a7c8d7a92ab4bad">More...</a><br /></td></tr>
<tr class="separator:aeba6a5ee540ee88b2a7c8d7a92ab4bad inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_file_loader"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_file_loader')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_file_loader.html">FileLoader</a></td></tr>
<tr class="memitem:a0954776182dd01364bdb216539ce398b inherit pro_methods_class_file_loader"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_file_loader.html#a0954776182dd01364bdb216539ce398b">~FileLoader</a> ()</td></tr>
<tr class="separator:a0954776182dd01364bdb216539ce398b inherit pro_methods_class_file_loader"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="memTemplParams" colspan="2"><a id="a0b38fd3197a742fdb2ff68ac4fcd4b0f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a> = std::unique_ptr&lt; T, <a class="el" href="struct_communicator_1_1_deleter.html">Deleter</a> &gt;</td></tr>
<tr class="memdesc:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes of UniquePtr&lt;T&gt; <br /></td></tr>
<tr class="separator:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_struct_xs_callback_plain_c"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_struct_xs_callback_plain_c')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a></td></tr>
<tr class="memitem:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">m_onAllBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">More...</a><br /></td></tr>
<tr class="separator:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">m_onAllDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">More...</a><br /></td></tr>
<tr class="separator:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">m_onAllLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">More...</a><br /></td></tr>
<tr class="separator:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">m_onAllRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">More...</a><br /></td></tr>
<tr class="separator:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">m_onBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">More...</a><br /></td></tr>
<tr class="separator:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">More...</a><br /></td></tr>
<tr class="separator:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">More...</a><br /></td></tr>
<tr class="separator:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">m_onDataUnavailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable.  <a href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">More...</a><br /></td></tr>
<tr class="separator:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">More...</a><br /></td></tr>
<tr class="separator:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">More...</a><br /></td></tr>
<tr class="separator:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">More...</a><br /></td></tr>
<tr class="separator:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">m_onLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">More...</a><br /></td></tr>
<tr class="separator:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">m_onMessageDetected</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="group___callbacks.html#ga9eb5e439c458d9704f3ddc05675f8193">More...</a><br /></td></tr>
<tr class="separator:ga9eb5e439c458d9704f3ddc05675f8193 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="group___callbacks.html#ga1f44ee52c284329ef2deb811ec162833">More...</a><br /></td></tr>
<tr class="separator:ga1f44ee52c284329ef2deb811ec162833 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="group___callbacks.html#gadb3ec2b8c9d9a437d6979ca3285abc90">More...</a><br /></td></tr>
<tr class="separator:gadb3ec2b8c9d9a437d6979ca3285abc90 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">More...</a><br /></td></tr>
<tr class="separator:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="group___callbacks.html#gade81af9d98086c3a760ffa3686045c63">More...</a><br /></td></tr>
<tr class="separator:gade81af9d98086c3a760ffa3686045c63 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">More...</a><br /></td></tr>
<tr class="separator:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">m_onRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">More...</a><br /></td></tr>
<tr class="separator:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">m_onRestoreCommunication</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occurred.  <a href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">More...</a><br /></td></tr>
<tr class="separator:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">m_onTransmissionRequest</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">More...</a><br /></td></tr>
<tr class="separator:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">More...</a><br /></td></tr>
<tr class="separator:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">More...</a><br /></td></tr>
<tr class="separator:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:ae97ac949b7898d0d52cd1e7e4db8f7a6 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="ae97ac949b7898d0d52cd1e7e4db8f7a6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ae97ac949b7898d0d52cd1e7e4db8f7a6">m_defaultTimeout</a></td></tr>
<tr class="memdesc:ae97ac949b7898d0d52cd1e7e4db8f7a6 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default timeout variable. <br /></td></tr>
<tr class="separator:ae97ac949b7898d0d52cd1e7e4db8f7a6 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90164a6964ce680a2bb6c750e3121437 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a90164a6964ce680a2bb6c750e3121437"></a>
<a class="el" href="classxsens_1_1_mutex.html">xsens::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a90164a6964ce680a2bb6c750e3121437">m_handleMux</a></td></tr>
<tr class="memdesc:a90164a6964ce680a2bb6c750e3121437 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle mutex. <br /></td></tr>
<tr class="separator:a90164a6964ce680a2bb6c750e3121437 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852b00fd08541b3fc1a7ff12684b75f9 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a852b00fd08541b3fc1a7ff12684b75f9"></a>
<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a852b00fd08541b3fc1a7ff12684b75f9">m_lastResult</a></td></tr>
<tr class="memdesc:a852b00fd08541b3fc1a7ff12684b75f9 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A last result variable. <br /></td></tr>
<tr class="separator:a852b00fd08541b3fc1a7ff12684b75f9 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65c6bae276812a005291e60b9d2c47b inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="ab65c6bae276812a005291e60b9d2c47b"></a>
<a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab65c6bae276812a005291e60b9d2c47b">m_lastResultText</a></td></tr>
<tr class="memdesc:ab65c6bae276812a005291e60b9d2c47b inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A last result string. <br /></td></tr>
<tr class="separator:ab65c6bae276812a005291e60b9d2c47b inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0afe5fa12dec79e590dc1dbcde56281 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="ab0afe5fa12dec79e590dc1dbcde56281"></a>
<a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab0afe5fa12dec79e590dc1dbcde56281">m_masterDeviceId</a></td></tr>
<tr class="memdesc:ab0afe5fa12dec79e590dc1dbcde56281 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A master device ID. <br /></td></tr>
<tr class="separator:ab0afe5fa12dec79e590dc1dbcde56281 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e99c203184a28f906cda4bea0498e8b inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a4e99c203184a28f906cda4bea0498e8b"></a>
<a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4e99c203184a28f906cda4bea0498e8b">m_masterInfo</a></td></tr>
<tr class="memdesc:a4e99c203184a28f906cda4bea0498e8b inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A master device object. <br /></td></tr>
<tr class="separator:a4e99c203184a28f906cda4bea0498e8b inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ec352c0ac50f5c333baff1943e87d7 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="aa0ec352c0ac50f5c333baff1943e87d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aa0ec352c0ac50f5c333baff1943e87d7">m_preparedForDestruction</a></td></tr>
<tr class="memdesc:aa0ec352c0ac50f5c333baff1943e87d7 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepared for destruction boolean variable. <br /></td></tr>
<tr class="separator:aa0ec352c0ac50f5c333baff1943e87d7 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4720fef928a6aaab1dc7ec743f53a173 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a4720fef928a6aaab1dc7ec743f53a173"></a>
std::shared_ptr&lt; <a class="el" href="class_protocol_manager.html">ProtocolManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4720fef928a6aaab1dc7ec743f53a173">m_protocolManager</a></td></tr>
<tr class="memdesc:a4720fef928a6aaab1dc7ec743f53a173 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shared pointer to protocl manager. <br /></td></tr>
<tr class="separator:a4720fef928a6aaab1dc7ec743f53a173 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6345ad9fb045e3d1de7c2370deaeef63 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a id="a6345ad9fb045e3d1de7c2370deaeef63"></a>
std::unique_ptr&lt; <a class="el" href="classxsens_1_1_reply_monitor.html">xsens::ReplyMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a6345ad9fb045e3d1de7c2370deaeef63">m_replyMonitor</a></td></tr>
<tr class="memdesc:a6345ad9fb045e3d1de7c2370deaeef63 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unique pointer to a reply monitor. <br /></td></tr>
<tr class="separator:a6345ad9fb045e3d1de7c2370deaeef63 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that is used for the communcation with a mtb file. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a03d80fc4d26de6b4d9c3f99b7e340f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d80fc4d26de6b4d9c3f99b7e340f65">&#9670;&nbsp;</a></span>~MtbFileCommunicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MtbFileCommunicator::~MtbFileCommunicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa81b981acbb7792e315d876866ed1912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81b981acbb7792e315d876866ed1912">&#9670;&nbsp;</a></span>abortLoadLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::abortLoadLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort a process that takes a long time to complete. </p>
<p>This currently only includes <a class="el" href="class_mtb_file_communicator.html#a61f7c132f9cd8608723628afa6ccb152" title="Read a log file into cache.">readLogFile()</a> </p>

<p>Implements <a class="el" href="struct_communicator.html#adae4ff2e76a332cb0106c373f342bc79">Communicator</a>.</p>

</div>
</div>
<a id="a004d7d02ad4007707f78064a658dc930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004d7d02ad4007707f78064a658dc930">&#9670;&nbsp;</a></span>addProtocolHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::addProtocolHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_protocol_handler.html">IProtocolHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the protocol handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>: The protocol hanlder to add </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="struct_communicator.html#ab9133a96d8f5d3f602981bcf1d8b74ac">Communicator</a>.</p>

</div>
</div>
<a id="a78208205ae08de9eb3c5c6af6ec98ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78208205ae08de9eb3c5c6af6ec98ae9">&#9670;&nbsp;</a></span>closeLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::closeLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the log file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the log file was successfully closed or never open </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a40bb7b535e5fbcb2657a1aa09d0ccd9e">Communicator</a>.</p>

</div>
</div>
<a id="a282c87d08be4df4711e6d98f57d3027d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282c87d08be4df4711e6d98f57d3027d">&#9670;&nbsp;</a></span>doTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::doTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretend to be a live system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message to send </td></tr>
    <tr><td class="paramname">rcv</td><td>The message to receive </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout in ms</td></tr>
  </table>
  </dd>
</dl>
<p>This one is nowhere near finished, but it does the trick for simple systems if a reply is available. </p><dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ab5c7243e499160cc244138727cc9fc3c">Communicator</a>.</p>

</div>
</div>
<a id="aadfac8c5baf5899efdf13d3ab571d30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfac8c5baf5899efdf13d3ab571d30f">&#9670;&nbsp;</a></span>getDeviceId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::getDeviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to get device ID. </p>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ad8bae91c2bbbfd74e56ff0ee1bdb27d5">Communicator</a>.</p>

</div>
</div>
<a id="a49ce6dc7dfa92438f88c1bee18197f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ce6dc7dfa92438f88c1bee18197f12">&#9670;&nbsp;</a></span>gotoConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::gotoConfig </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to go to config mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detectRs485</td><td>when set to true it will try to detect and use an RS485 interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a7e183d2fdad136d39d96bb69da118dc4">Communicator</a>.</p>

</div>
</div>
<a id="a345f59969ccaa52892a8484bb987267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345f59969ccaa52892a8484bb987267e">&#9670;&nbsp;</a></span>gotoMeasurement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::gotoMeasurement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to go to measurement mode. </p>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a29fecb5f975db28879d7e8cdb600ddc3">Communicator</a>.</p>

</div>
</div>
<a id="ad1d3ca888b5603ab469bc1f1ac79de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d3ca888b5603ab469bc1f1ac79de6e">&#9670;&nbsp;</a></span>isLoadLogFileInProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::isLoadLogFileInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if load log file is in progress </dd></dl>

<p>Reimplemented from <a class="el" href="struct_communicator.html#aeecf3bf1cbd0f42de59123450833d680">Communicator</a>.</p>

</div>
</div>
<a id="a87ab4a685db5ae979f0c5d8a711ab06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ab4a685db5ae979f0c5d8a711ab06b">&#9670;&nbsp;</a></span>isPortOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::isPortOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the port is open </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a5e3961efd576ab1736b51b6675a28fb3">Communicator</a>.</p>

</div>
</div>
<a id="aaebdd9ca5ea57f90521be8b1dc1965c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebdd9ca5ea57f90521be8b1dc1965c7">&#9670;&nbsp;</a></span>logFileReadPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> MtbFileCommunicator::logFileReadPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the read position of the log file. </p>
<p>This function will return the current read position in the open log file in bytes from the start. </p><dl class="section note"><dt>Note</dt><dd>The read and write positions of log files are completely independent of each other. </dd>
<dd>
There is a look-ahead cache in place so even when the read position is already at the end of the file, there may still be some messages left to be read. For this reason, this function will at most return filesize-1 until the message queue is empty. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>To reset the read position, use resetLogFileReadPosition. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_mtb_file_communicator.html#a28b0202be2b95f6bcc0f5d5bda35d7d8" title="Restart reading from the start of the open log file.">resetLogFileReadPosition</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The file read position </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a1d2a49e9a8ff16018c5b8d5631c63e97">Communicator</a>.</p>

</div>
</div>
<a id="a98c932f470af852f095a7ff41f774234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c932f470af852f095a7ff41f774234">&#9670;&nbsp;</a></span>openLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::openLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a log file for input. </p>
<p>This function opens the supplied log file for reading. The function will fail if a serial connection is currently open. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to open. It is recommended to use a fully qualified path+filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only available in configuration mode. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_mtb_file_communicator.html#a78208205ae08de9eb3c5c6af6ec98ae9" title="Close the log file.">closeLogFile</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ab869c9bf1289e05b4289060cb3d113b2">Communicator</a>.</p>

</div>
</div>
<a id="ae49568e601aed36f9b2f1ec4da338f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49568e601aed36f9b2f1ec4da338f46">&#9670;&nbsp;</a></span>openPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::openPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a>&#160;</td>
          <td class="paramname"><em>stage</em> = <code>OPS_Full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portInfo</td><td>A port information that you want to open </td></tr>
    <tr><td class="paramname">stage</td><td>A openning stage of a communication port </td></tr>
    <tr><td class="paramname">detectRs485</td><td>When set to true it will try to detect and use an RS485 interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is successfully open </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aa111ea807518c31210865dc0343a3b22">Communicator</a>.</p>

</div>
</div>
<a id="a90baa66d3f9098833531da0b8be26b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90baa66d3f9098833531da0b8be26b4a">&#9670;&nbsp;</a></span>portInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> MtbFileCommunicator::portInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_xs_port_info.html" title="Contains a descriptor for opening a communication port to an Xsens device.">XsPortInfo</a> of the current port </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a1a4ba050c31e70abd4565dd505d6387c">Communicator</a>.</p>

</div>
</div>
<a id="a61f7c132f9cd8608723628afa6ccb152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f7c132f9cd8608723628afa6ccb152">&#9670;&nbsp;</a></span>readLogFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::readLogFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a log file into cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>: The device to read log from</td></tr>
  </table>
  </dd>
</dl>
<p>Read all data for <em>inf</em> into the cache </p><dl class="section see"><dt>See also</dt><dd>XsControl::loadLogFile </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if successful </dd></dl>

<p>Implements <a class="el" href="class_file_loader.html#a84bf0c0d55da2cc3e6e8ec12496d8cd6">FileLoader</a>.</p>

</div>
</div>
<a id="a312ba4a98023822449dae795d7ae4a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312ba4a98023822449dae795d7ae4a72">&#9670;&nbsp;</a></span>readMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a> MtbFileCommunicator::readMessage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a message from the open file. </p>
<p>This function will attempt to read a full message from the open device (file or COM port or USB port). If msgId is non-0, the function will look for a specific message ID. The function will read from the device, but it won't wait for data to become available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>Either 0 to read the first available message or non-0 to look for a specific message with this ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The message that was read or if no matching message was found a cleared message. </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a692484e8c4f7a588f49a3cb1123a962f">Communicator</a>.</p>

</div>
</div>
<a id="a3c86e20a386e73ddce139bb7e312e9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c86e20a386e73ddce139bb7e312e9fa">&#9670;&nbsp;</a></span>readMessageFromStartOfFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a> MtbFileCommunicator::readMessageFromStartOfFile </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxMsgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a message from the start of the open file. </p>
<p>This function will reset the read position in the file to the start and will then search for the message with the given message ID. After the message has been found (or not) the read position will be restored to its original position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>The ID of the message to search for </td></tr>
    <tr><td class="paramname">maxMsgs</td><td>Optional parameter to limit the maximum number of messages to search. When 0, the function will continue until the message has been found or the end of the file has been reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The messsage that was read </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#af2651a48958605e80d6e3e4519f438d6">Communicator</a>.</p>

</div>
</div>
<a id="a9b8207e51e5e32f36da3c50688b75bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8207e51e5e32f36da3c50688b75bf5">&#9670;&nbsp;</a></span>readMessagesFromStartOfFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="struct_xs_message.html">XsMessage</a> &gt; MtbFileCommunicator::readMessagesFromStartOfFile </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxMsgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read multiple similar messages from the start of the open file. </p>
<p>This function will reset the read position in the file to the start and will then search for all messages with the given message ID. Afterwards the read position will be restored to its original position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>The ID of the message to search for. </td></tr>
    <tr><td class="paramname">maxMsgs</td><td>Optional parameter to limit the maximum number of messages to search. When 0, the function will continue until the end of the file has been reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The messsage that was read </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aeba8fe953887ceea6a42ae27f80d58d7">Communicator</a>.</p>

</div>
</div>
<a id="a81507126b264871d0a5538ad4c9a9865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81507126b264871d0a5538ad4c9a9865">&#9670;&nbsp;</a></span>readNextMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a> MtbFileCommunicator::readNextMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next message from the open file. </p>
<dl class="section return"><dt>Returns</dt><dd>The message that was read or an empty message if no message was found (end-of-file for example). </dd></dl>

</div>
</div>
<a id="a23cb1ea7f701b999619906a9d15978ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cb1ea7f701b999619906a9d15978ec">&#9670;&nbsp;</a></span>readSinglePacketFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::readSinglePacketFromFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> from an open log file. </p>
<p>Read a single <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> from the log file and place it in the correct data cache(s) </p><dl class="section return"><dt>Returns</dt><dd>XRV_OK if successful </dd></dl>

<p>Implements <a class="el" href="class_file_loader.html#a1938a67d2692ba9052d94c73901debbc">FileLoader</a>.</p>

</div>
</div>
<a id="a515b5fc108dd7f5e6ff82ec8ccae08ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515b5fc108dd7f5e6ff82ec8ccae08ec">&#9670;&nbsp;</a></span>reopenPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::reopenPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a>&#160;</td>
          <td class="paramname"><em>stage</em> = <code>OPS_Full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipDeviceIdCheck</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reopens the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>A openning stage of a communication port </td></tr>
    <tr><td class="paramname">skipDeviceIdCheck</td><td>When set to true it will skip device ID check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is successfully reopened </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aa96111aa187a632a62242b5d3dd08787">Communicator</a>.</p>

</div>
</div>
<a id="a28b0202be2b95f6bcc0f5d5bda35d7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b0202be2b95f6bcc0f5d5bda35d7d8">&#9670;&nbsp;</a></span>resetLogFileReadPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::resetLogFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart reading from the start of the open log file. </p>
<p>This function resets the read position to the start of the open log file. Only the read position is affected, the write position remains the same. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_mtb_file_communicator.html#a98c932f470af852f095a7ff41f774234" title="Open a log file for input.">openLogFile</a> </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aacf0fb26ffe0677d133ee15b2c630f51">Communicator</a>.</p>

</div>
</div>
<a id="ace1645929c7d07b082781a3d242be48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1645929c7d07b082781a3d242be48f">&#9670;&nbsp;</a></span>setGotoConfigTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::setGotoConfigTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the timeout for the gotoConfig function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The desired timeout value in ms, if 0 the default value is used </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="struct_communicator.html#ac2fe2ba5aa3e4d0b89fa9cf7379444d3">Communicator</a>.</p>

</div>
</div>
<a id="ab63788ee066d43dc26c275d4440ea4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63788ee066d43dc26c275d4440ea4d3">&#9670;&nbsp;</a></span>waitForLastTaskCompletion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::waitForLastTaskCompletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the last processing task to complete in the threadpool. </p>
<p>This function is usually called after abort() to make sure that no more processing is going on. </p>

<p>Implements <a class="el" href="struct_communicator.html#aa9dfe2fd5d802d47bfd5281bd5da471a">Communicator</a>.</p>

</div>
</div>
<a id="a449e545f43bff28ba7971288f1f4f924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449e545f43bff28ba7971288f1f4f924">&#9670;&nbsp;</a></span>writeMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::writeMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write message to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>a message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful write, false otherwise. This doesn't guarantee proper delivery of the message. Use doTransaction for that </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ad4ba37c181a66e917085a31ab09205fc">Communicator</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_mtb_file_communicator.html">MtbFileCommunicator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
