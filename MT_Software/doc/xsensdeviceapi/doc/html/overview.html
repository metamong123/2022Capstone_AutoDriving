<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xsens Device API: Overview of the Xsens Device API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xsenslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xsens Device API
   &#160;<span id="projectnumber">2021.4.0</span>
   </div>
   <div id="projectbrief">Xsens Device API objects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Overview of the Xsens Device API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="s_introduction"></a>
Introduction</h1>
<p>This document gives an introduction to the Xsens Device API (XDA). It serves as a starting point for software developers interested in assessing the basis of the SDK. Information regarding the design considerations can be found on this page <a class="el" href="p_background.html">Xsens Device API Objectives and Considerations</a>.</p>
<h1><a class="anchor" id="s_setup"></a>
Set-up</h1>
<p>The Xsens Device API is implemented as illustrated in the figure below: </p><div class="doxyimage"> <div class="image">
<img src="application_setup.png" alt=""/>
<div class="caption">
Application development set-up</div></div>
</div><p>The XDA provides an interface between a host application and either one ore more physical Xsens devices or a file containing the data recorded from Xsens devices. An example of a host application is Xsens's own MT Manager tool as depicted in the figure. <br  />
<br  />
 As can be seen, the host application developer can choose to use a COM, C or C++ interface. The C++ interface is not available in compiled form but is provided as part of the SDK as source code that is incorporated in the C header files. This C++ interface code implements a convenience wrapper around the C API. This means that the developer does not have to deal with memory management (i.e. easy object-lifetime management) as the class implementation takes care of this. <br  />
<br  />
 The API comprises of two C-interface libraries that are supplied for MS Windows (32 and 64 bit) and Linux. These are:</p>
<ul>
<li>XsTypes that contains generic types (vectors, matrices, quaternions, etc.) and some basic operations on those types. </li>
<li>Xsens Device API that contains the access to functionality as implemented in Xsens devices.</li>
</ul>
<p>The Xsens Device API library depends on the XsTypes, while XsTypes is an independent library.</p>
<p>The remainder of this document focuses on the C++ interface of the Xsens Device API only. For using the C or COM interface please refer to the <a class="el" href="p_examples.html">Code Examples</a> page.<br  />
 </p>
<h2><a class="anchor" id="ss_mainClasses"></a>
Important Classes of the C++ interface</h2>
<p>The following six classes available in the C++ interface are classes that are extensively used by a host application. Knowing what these classes are about will give the developer a starting point for implementing a basic application. <br  />
<br  />
 </p><ul>
<li><a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a>: The central class of the XDA. It handles the administration of devices and global settings. It keeps track of all opened devices as <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> objects. An application creates a single <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object at startup and will use it to access devices and their data.</li>
</ul>
<ul>
<li><a class="el" href="class_xs_scanner.html" title="Provides static functionality for scanning for Xsens devices.">XsScanner</a>: Used to scan ports for Xsens devices. Detected devices have an <a class="el" href="struct_xs_device_id.html" title="Contains an Xsens device ID and provides operations for determining the type of device.">XsDeviceId</a> and a portname.</li>
</ul>
<ul>
<li><a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>: Provides an interface to control and configure a device. It will also process data that arrives for the particular device.</li>
</ul>
<ul>
<li><a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>: Encapsulates a single measurement from a device. Such a measurement can consist of one or more data types. For example an acceleration vector and a rate of turn vector. To check if a particular data type is present in the packet use the corresponding <em>contains</em> function. If the <em>contains</em> function returns true the data can safely be read from the packet. If for example one is interested in the orientation data the <a class="el" href="struct_xs_data_packet.html#a6153380c629e19157b1cf76993c6fdb0" title="Check if data item contains orientation Data of any kind.">XsDataPacket::containsOrientation</a> function can be used. If the result is true the orientation data can be obtained through the <a class="el" href="struct_xs_data_packet.html#a10ba4b80a6f55c7d866ed0517c097add" title="Return the orientation component of a data item as a quaternion.">XsDataPacket::orientationQuaternion</a> function.</li>
</ul>
<ul>
<li><a class="el" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API.">XsCallback</a>: Provides event handling. If the host application needs to receive events from XDA a sub class of <a class="el" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API.">XsCallback</a> is created that overrides the virtual event functions the application needs to handle. An instance of the subclass is registered with the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object. More information regarding callback implementation can be found in the <a class="el" href="overview.html#s_concurrency">Concurrency</a> section.</li>
</ul>
<ul>
<li><a class="el" href="struct_xs_device_id.html" title="Contains an Xsens device ID and provides operations for determining the type of device.">XsDeviceId</a>: Provides a unique identifier for an Xsens device. Every Xsens product has a serial number. This is usually found on the bottom/back of the casing. The serial number is called the DeviceId in the software.</li>
</ul>
<h2><a class="anchor" id="ss_deviceTree"></a>
Device Hierarchy</h2>
<p>An Xsens device connects to the system through a communication port (represented by the "Serial communication driver" box in the figure above). The underlying hardware connection for this communication port may be a serial port or a USB connection. A device that is connected directly to the communication port is called a <em>main</em> <em>device</em>. Some main devices, for example an Awinda Station, can expose a set of child devices. These are devices that connect to the main device and all communication between these child devices and XDA goes through the communication port of the main device. <br  />
<br  />
 At startup the host application will usually discover the available devices through use of the XsControl::scanPorts function. This function returns a list of communication ports on which an Xsens device is detected/connected. Please note that the devices IDs associated with these ports are of main devices only. Only after opening a main device (using <a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd" title="Open a communication channel on serial port with the given portname.">XsControl::openPort</a>) will the child devices become available. <br  />
<br  />
 <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> instances of these children can be obtained either through calling <a class="el" href="struct_xs_device.html#a3f5821d929b156dcfdde385f27af43fd" title="Return a managed array containing the child-devices this device has. For standalone devices this is a...">XsDevice::children</a> on a main device or by passing the child's device ID to the <a class="el" href="struct_xs_control.html#a908f5a025aef35e11a4e4583eb0c55a8" title="Returns the XsDevice interface object associated with the supplied deviceId.">XsControl::device</a> function. A list of all device IDs, for both main and child devices, is returned by the <a class="el" href="struct_xs_control.html#a522bdd45d17b66a9297af560fb4be639" title="Get the device IDs of all the connected devices.">XsControl::deviceIds</a> function.<br  />
<br  />
 </p>
<h1><a class="anchor" id="s_deviceDiversity"></a>
Device Diversity</h1>
<p>The XDA is designed to expose all the possible functions that could be supported by an Xsens device. However not every Xsens device supports all functionality, e.g. an MTi does not support getting a position estimate whereas the MTi-G does. This means that whether the function returns a meaningful result depends on the connected device. <br  />
For more information about the availability of the Xsens Device API functionalities please refer to <a class="el" href="group__cinterfaceavailability.html">C Interface Availability</a> for the C interface and to <a class="el" href="group__cppinterfaceavailability.html">C++ Interface Availability</a> for the C++ interface. <br  />
<br  />
 Internally the XDA is implemented using an object oriented approach where the functionality for a particular kind of Xsens device is implemented as a subclass derived from <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> overriding only those functions it supports. So where the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> class supports all functions the derived classes may only support a subset. This is schematically illustrated in the figure below:</p>
<div class="doxyimage"> <div class="image">
<img src="function_exposure.png" alt=""/>
<div class="caption">
Schematic illustration of how all the functions in the Xsens Device API are exposed but not all functions are supported by all devices.</div></div>
 </div><p>The described approach requires a way for the developer to determine whether a certain connected device (e.g. MTi, MTw) supports certain functionality. In principle the developer needs to take care of only using functions that are supported by the connected device. However, to prevent unexpected behavior, the Xsens Device API still offers a safeguard against the program calling functions that are not supported by the connected device. <br  />
<br  />
 If a function is not supported for a particular device the default version of that function as implemented by <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> will be executed. The default functions will indicate that the function is unsupported using the standard error handling mechanism of the XDA. In this mechanism the application can use the <a class="el" href="struct_xs_control.html#a9c9352106766f7bdfc5ad4b13ec34ecc" title="Get the result value of the last operation.">XsControl::lastResult</a> function to check if the last call to an XDA function succeeded. In case of an unsupported function the result will be XRV_UNSUPPORTED.<br  />
<br  />
 Furthermore to prevent an immediate application crash the default functions will always return a value. In case of complex return types (i.e. a struct or class object) the return type will have an <code>empty()</code> member function that can be used to check if the result can safely be used by the application. For simple types the application must use the result of the <a class="el" href="struct_xs_control.html#a9c9352106766f7bdfc5ad4b13ec34ecc" title="Get the result value of the last operation.">XsControl::lastResult</a> function.<br  />
<br  />
 </p>
<h2><a class="anchor" id="ss_programFlow"></a>
Program Flow</h2>
<p>This section describes the typical program flow of an application using the XDA. Refer to the <a class="el" href="p_examples.html">Code Examples</a> page for some simple application examples reflecting the flow described here.<br  />
The Awinda System has a slighty different workflow and is described here: <a class="el" href="awindaworkflow.html">Workflow using the Xsens Awinda System</a>. <br  />
<br  />
 An application that wants to process data from one or more Xsens device will roughly follow the following steps</p>
<ul>
<li>
Startup phase  <ol>
<li>
<p class="startli">Initialize XDA </p><div class="groupText"> The application starts with the creation of an <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object using the <a class="el" href="struct_xs_control.html#a6c54fd6126e517381f9a063c5fb8a117" title="Construct a new XsControl* object. Clean it up with the destruct() function or delete the object.">XsControl::construct</a> function. </div><p class="endli"></p>
</li>
<li>
<p class="startli">Discover devices </p><div class="groupText"> The application detects devices available to the system using the <a class="el" href="class_xs_scanner.html#a42f1eac216fdfa16fd001264d7763202" title="Scan all ports for Xsens devices.">XsScanner::scanPorts</a> function. This function will return all communication ports to which Xsens devices are connected. </div><p class="endli"></p>
</li>
<li>
<p class="startli">Open devices of interest </p><div class="groupText"> The port information obtained in the previous step is used to open devices of interest using the <a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd" title="Open a communication channel on serial port with the given portname.">XsControl::openPort</a> function. </div><p class="endli"></p>
</li>
<li>
<p class="startli">Configure devices </p><div class="groupText"> If needed the application configures the open devices. Through the <a class="el" href="struct_xs_control.html#a908f5a025aef35e11a4e4583eb0c55a8" title="Returns the XsDevice interface object associated with the supplied deviceId.">XsControl::device</a> function the application obtains <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> instances required to do the configuration. Typical configuration actions are setting the output data format and data rate to the desired values. </div><p class="endli"></p>
</li>
<li>
<p class="startli">Prepare for data handling (event based) </p><div class="groupText"> With event based data handling the application is signalled with an <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> as soon as it arrives. To enable this a callback object must be registered. The application creates an object derived from <a class="el" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API.">XsCallback</a> that overrides the <a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onLiveDataAvailable</a> function. The object is registered with XDA using the <a class="el" href="struct_xs_control.html#a189065247d7fb3758a355c403c68866d" title="Add a callback handler to the list.">XsControl::addCallbackHandler</a> function. </div><p class="endli"></p>
</li>
<li>
<p class="startli">Switch devices to measurement mode </p><div class="groupText"> The devices are set to measurement mode. The application can do this either per <b>main</b> device with the <a class="el" href="struct_xs_device.html#a71743a68785ec3af6c5c5763a69aca62" title="Put this device in measurement mode.">XsDevice::gotoMeasurement</a> function or for all devices simultaneously using <a class="el" href="struct_xs_control.html#a7e568e756863a1b90156a3edf11a6126" title="Place all sensors connected through a serial port into Measurement Mode.">XsControl::gotoMeasurement</a> </div><p class="endli"></p>
</li>
</ol>
</li>
<li>
Processing phase  <ol>
<li>
<p class="startli">Handle incoming data </p><div class="groupText"> The onPostProcess function of the callback object registered in the startup phase will be called whenever new data is available. The function gets a pointer to the newly available <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> as parameter. The <a class="el" href="struct_xs_data_packet.html#a5d5de9e35c85b44c0158e1389ada848a" title="Return the device ID associated with the data packet.">XsDataPacket::deviceId</a> function is used to determine from which device the packet is received. Refer to <a class="el" href="overview.html#s_concurrency">Concurrency</a> for a more indepth view on event based data handling </div><p class="endli"></p>
</li>
<li>
<p class="startli">Check for completion </p><div class="groupText"> The application checks the conditions required for process completion, these are application defined. If the conditions are met the Exit phase is entered </div><p class="endli"></p>
</li>
</ol>
</li>
<li>
Exit phase  <ol>
<li>
<p class="startli">Close open devices </p><div class="groupText"> All open devices are closed. The application uses the <a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79" title="Close the serial port with the given portname.">XsControl::closePort</a> function on each openend device to do this or the Xscontrol::close function to close all open devices. Closing the device will automatically change the state of the device from measurement mode to config mode. </div><p class="endli"></p>
</li>
<li>
Clean up XDA <div class="groupText"> The application releases the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object created at startup using the <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">XsControl::destruct</a> function. </div> </li>
</ol>
</li>
</ul>
<h2><a class="anchor" id="s_concurrency"></a>
Concurrency</h2>
<p>The Xsens Device SDK implements a concurrent system. This means that: </p><ul>
<li>The XDA functions are implemented in a thread-safe way. </li>
<li>The XDA framework supports asynchronous events.</li>
</ul>
<p>To make the XDA functions thread-safe, data manipulation is controlled tightly and care is taken that function calls are non-blocking. This last point is also achieved by caching all information that would be required from the device.<br  />
<br  />
 The asynchronous events are handled by implementing a <em>callback</em> object. This can be achieved through creating a class inherited from <a class="el" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API.">XsCallback</a> that overrides the virtual event functions. The callback object is registered in the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object.<br  />
<br  />
 To illustrate the set-up, see the figure and description given below: </p><div class="doxyimage"> <div class="image">
<img src="callback_example.png" alt=""/>
<div class="caption">
Illustrative example of the callback functionality</div></div>
 </div><p>In this example the application starts the measurements at the devices using the <a class="el" href="struct_xs_device.html#a71743a68785ec3af6c5c5763a69aca62" title="Put this device in measurement mode.">XsDevice::gotoMeasurement</a> function. From this point on the connected device will generate data. Data will be sent over its serial connection using the XBus protocol. Each <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> object contains a polling thread that will read this data from the serial stream. This "raw data" might require some further processing before it can be offered to the application. Since this could require some processing time, a shared worker thread is used in which the data is processed while the reader thread can handle any new incoming data. This system prevents buffer overflows and subsequent data loss.<br  />
<br  />
 After the data is processed, the worker thread will call the onPostProcess() callback function. This call will end up in the overloaded function of the callback object implemented by the application developer.<br  />
<br  />
 It is a good practice to take any actions based on callbacks in a separate thread. This can be achieved by using an OS messaging mechanism to forward the event to the application's main event loop. The callback function runs in the context of <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> worker thread and problems can occur if XDA functions that change the state of the XDA (such as gotoConfig and closePort) or the application (such as showing a window) are called from within the callback handler. For example, most GUI-toolkits require that all operations are performed from a single thread. Also, any time-consuming processing (e.g. graphical display) that is performed inside the callback function will block the worker thread, which causes a delay in data-processing and must therefore be prevented.<br  />
<br  />
 Another important consideration is the data that is passed as parameter of the callback function. To prevent unnecessary copying and thereby reducing time spent in callback functions, the data is given as a pointer to an <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> maintained by the XDA. For the application, this data is only valid within the scope of the callback function. The calling worker thread remains in control of the data and is responsible for cleaning it up when it is no longer necessary. The developer can create an effective implementation in which only the data is copied that is actually required by the application and only create a message to be sent to the application thread containing this specific data. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
